/*eslint-disable */
var _windowShim = require("../lib/shims/window-shim");
var _documentShim = require("../lib/shims/document-shim");
var _canvasShim = require("../lib/shims/canvas-shim");
var _imageShim = require("../lib/shims/image-shim");
var _rafShim = require("../lib/shims/raf-shim");
var _RESOURCES = require("./resources.json");

function glsl_functions_glsl_function_mod_gentype(ENVIRONMENT) {
    var HTMLElement = function() {};
    ENVIRONMENT.CONTEXT_LIST = [];
    ENVIRONMENT.tape.end = (function(tape_end) {
        return function() {
            _rafShim.clear();
            ENVIRONMENT.CONTEXT_LIST.forEach(function(gl) {
                (gl.destroy && gl.destroy());
            });
            ENVIRONMENT.CONTEXT_LIST = [];
            tape_end.call(ENVIRONMENT.tape);
        }
    })(ENVIRONMENT.tape.end);
    ENVIRONMENT._createContext = ENVIRONMENT.createContext;
    ENVIRONMENT.createContext = function(w, h, o) {
        var gl = ENVIRONMENT._createContext(w, h, o);
        ENVIRONMENT.CONTEXT_LIST.push(gl);
        return gl;
    };
    ENVIRONMENT.document = _documentShim(ENVIRONMENT);
    ENVIRONMENT.window = _windowShim(ENVIRONMENT);
    ENVIRONMENT.scriptList = {};
    ENVIRONMENT.canvasList = [].map(function(opts) {
        return _canvasShim(ENVIRONMENT, opts);
    });
    ENVIRONMENT.RESOURCES = _RESOURCES;
    ENVIRONMENT.BASEPATH = "glsl/functions";
    var document = ENVIRONMENT.document;
    var window = ENVIRONMENT.window;
    var Image = _imageShim;
    var requestAnimationFrame = _rafShim.requestAnimationFrame;
    var cancelAnimationFrame = _rafShim.cancelAnimationFrame;;
    /*
     ** Copyright (c) 2012 The Khronos Group Inc.
     **
     ** Permission is hereby granted, free of charge, to any person obtaining a
     ** copy of this software and/or associated documentation files (the
     ** "Materials"), to deal in the Materials without restriction, including
     ** without limitation the rights to use, copy, modify, merge, publish,
     ** distribute, sublicense, and/or sell copies of the Materials, and to
     ** permit persons to whom the Materials are furnished to do so, subject to
     ** the following conditions:
     **
     ** The above copyright notice and this permission notice shall be included
     ** in all copies or substantial portions of the Materials.
     **
     ** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     ** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     ** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     ** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     ** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
     ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
     ** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
     */

    var CONSOLE = (1, eval)("console")

    function enableJSTestPreVerboseLogging() {}

    function initTestingHarnessWaitUntilDone() {}

    function initTestingHarness() {}

    function nonKhronosFrameworkNotifyDone() {
        // WebKit Specific code. Add your code here.
        ENVIRONMENT.tape.end()
    }

    function reportTestResultsToHarness(success, msg) {
        //Garbage
    }

    function notifyFinishedToHarness() {
        ENVIRONMENT.tape.end()
    }

    function description(msg) {
        CONSOLE.log("DESCRIPTION:", msg)
    }

    function debug(msg) {
        CONSOLE.log("DEBUG:", msg)
    }

    function escapeHTML(text) {
        return text.replace(/&/g, "&amp;").replace(/</g, "&lt;");
    }

    function testPassed(msg) {
        ENVIRONMENT.tape.pass(msg)
    }

    function testFailed(msg) {
        ENVIRONMENT.tape.fail(msg)
    }

    function areArraysEqual(_a, _b) {
        try {
            if (_a.length !== _b.length)
                return false;
            for (var i = 0; i < _a.length; i++)
                if (_a[i] !== _b[i])
                    return false;
        } catch (ex) {
            return false;
        }
        return true;
    }

    function isMinusZero(n) {
        // the only way to tell 0 from -0 in JS is the fact that 1/-0 is
        // -Infinity instead of Infinity
        return n === 0 && 1 / n < 0;
    }

    function isResultCorrect(_actual, _expected) {
        if (_expected === 0)
            return _actual === _expected && (1 / _actual) === (1 / _expected);
        if (_actual === _expected)
            return true;
        if (typeof(_expected) == "number" && isNaN(_expected))
            return typeof(_actual) == "number" && isNaN(_actual);
        if (Object.prototype.toString.call(_expected) == Object.prototype.toString.call([]))
            return areArraysEqual(_actual, _expected);
        return false;
    }

    function stringify(v) {
        if (v === 0 && 1 / v < 0)
            return "-0";
        else return "" + v;
    }

    function evalAndLog(_a) {
        if (typeof _a != "string")
            debug("WARN: tryAndLog() expects a string argument");

        // Log first in case things go horribly wrong or this causes a sync event.
        debug(_a);

        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            testFailed(_a + " threw exception " + e);
        }
        return _av;
    }

    function shouldBe(_a, _b, quiet) {
        if (typeof _a != "string" || typeof _b != "string")
            debug("WARN: shouldBe() expects string arguments");
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }
        var _bv = eval(_b);

        if (exception)
            testFailed(_a + " should be " + _bv + ". Threw exception " + exception);
        else if (isResultCorrect(_av, _bv)) {
            if (!quiet) {
                testPassed(_a + " is " + _b);
            }
        } else if (typeof(_av) == typeof(_bv))
            testFailed(_a + " should be " + _bv + ". Was " + stringify(_av) + ".");
        else
            testFailed(_a + " should be " + _bv + " (of type " + typeof _bv + "). Was " + _av + " (of type " + typeof _av + ").");
    }

    function shouldNotBe(_a, _b, quiet) {
        if (typeof _a != "string" || typeof _b != "string")
            debug("WARN: shouldNotBe() expects string arguments");
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }
        var _bv = eval(_b);

        if (exception)
            testFailed(_a + " should not be " + _bv + ". Threw exception " + exception);
        else if (!isResultCorrect(_av, _bv)) {
            if (!quiet) {
                testPassed(_a + " is not " + _b);
            }
        } else
            testFailed(_a + " should not be " + _bv + ".");
    }

    function shouldBeTrue(_a) {
        shouldBe(_a, "true");
    }

    function shouldBeFalse(_a) {
        shouldBe(_a, "false");
    }

    function shouldBeNaN(_a) {
        shouldBe(_a, "NaN");
    }

    function shouldBeNull(_a) {
        shouldBe(_a, "null");
    }

    function shouldBeEqualToString(a, b) {
        var unevaledString = '"' + b.replace(/"/g, "\"") + '"';
        shouldBe(a, unevaledString);
    }

    function shouldEvaluateTo(actual, expected) {
        // A general-purpose comparator.  'actual' should be a string to be
        // evaluated, as for shouldBe(). 'expected' may be any type and will be
        // used without being eval'ed.
        if (expected == null) {
            // Do this before the object test, since null is of type 'object'.
            shouldBeNull(actual);
        } else if (typeof expected == "undefined") {
            shouldBeUndefined(actual);
        } else if (typeof expected == "function") {
            // All this fuss is to avoid the string-arg warning from shouldBe().
            try {
                actualValue = eval(actual);
            } catch (e) {
                testFailed("Evaluating " + actual + ": Threw exception " + e);
                return;
            }
            shouldBe("'" + actualValue.toString().replace(/\n/g, "") + "'",
                "'" + expected.toString().replace(/\n/g, "") + "'");
        } else if (typeof expected == "object") {
            shouldBeTrue(actual + " == '" + expected + "'");
        } else if (typeof expected == "string") {
            shouldBe(actual, expected);
        } else if (typeof expected == "boolean") {
            shouldBe("typeof " + actual, "'boolean'");
            if (expected)
                shouldBeTrue(actual);
            else
                shouldBeFalse(actual);
        } else if (typeof expected == "number") {
            shouldBe(actual, stringify(expected));
        } else {
            debug(expected + " is unknown type " + typeof expected);
            shouldBeTrue(actual, "'" + expected.toString() + "'");
        }
    }

    function shouldBeNonZero(_a) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        if (exception)
            testFailed(_a + " should be non-zero. Threw exception " + exception);
        else if (_av != 0)
            testPassed(_a + " is non-zero.");
        else
            testFailed(_a + " should be non-zero. Was " + _av);
    }

    function shouldBeNonNull(_a) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        if (exception)
            testFailed(_a + " should be non-null. Threw exception " + exception);
        else if (_av != null)
            testPassed(_a + " is non-null.");
        else
            testFailed(_a + " should be non-null. Was " + _av);
    }

    function shouldBeUndefined(_a) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        if (exception)
            testFailed(_a + " should be undefined. Threw exception " + exception);
        else if (typeof _av == "undefined")
            testPassed(_a + " is undefined.");
        else
            testFailed(_a + " should be undefined. Was " + _av);
    }

    function shouldBeDefined(_a) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        if (exception)
            testFailed(_a + " should be defined. Threw exception " + exception);
        else if (_av !== undefined)
            testPassed(_a + " is defined.");
        else
            testFailed(_a + " should be defined. Was " + _av);
    }

    function shouldBeGreaterThanOrEqual(_a, _b) {
        if (typeof _a != "string" || typeof _b != "string")
            debug("WARN: shouldBeGreaterThanOrEqual expects string arguments");

        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }
        var _bv = eval(_b);

        if (exception)
            testFailed(_a + " should be >= " + _b + ". Threw exception " + exception);
        else if (typeof _av == "undefined" || _av < _bv)
            testFailed(_a + " should be >= " + _b + ". Was " + _av + " (of type " + typeof _av + ").");
        else
            testPassed(_a + " is >= " + _b);
    }

    function expectTrue(v, msg) {
        if (v) {
            testPassed(msg);
        } else {
            testFailed(msg);
        }
    }

    function shouldThrow(_a, _e) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        var _ev;
        if (_e)
            _ev = eval(_e);

        if (exception) {
            if (typeof _e == "undefined" || exception == _ev)
                testPassed(_a + " threw exception " + exception + ".");
            else
                testFailed(_a + " should throw " + (typeof _e == "undefined" ? "an exception" : _ev) + ". Threw exception " + exception + ".");
        } else if (typeof _av == "undefined")
            testFailed(_a + " should throw " + (typeof _e == "undefined" ? "an exception" : _ev) + ". Was undefined.");
        else
            testFailed(_a + " should throw " + (typeof _e == "undefined" ? "an exception" : _ev) + ". Was " + _av + ".");
    }

    function shouldBeType(_a, _type) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        var _typev = eval(_type);

        if (_av instanceof _typev) {
            testPassed(_a + " is an instance of " + _type);
        } else {
            testFailed(_a + " is not an instance of " + _type);
        }
    }

    function assertMsg(assertion, msg) {
        if (assertion) {
            testPassed(msg);
        } else {
            testFailed(msg);
        }
    }

    function gc() {}

    function finishTest() {
        ENVIRONMENT.tape.end()
    };;
    /*
     ** Copyright (c) 2012 The Khronos Group Inc.
     **
     ** Permission is hereby granted, free of charge, to any person obtaining a
     ** copy of this software and/or associated documentation files (the
     ** "Materials"), to deal in the Materials without restriction, including
     ** without limitation the rights to use, copy, modify, merge, publish,
     ** distribute, sublicense, and/or sell copies of the Materials, and to
     ** permit persons to whom the Materials are furnished to do so, subject to
     ** the following conditions:
     **
     ** The above copyright notice and this permission notice shall be included
     ** in all copies or substantial portions of the Materials.
     **
     ** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     ** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     ** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     ** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     ** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
     ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
     ** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
     */

    var canvas = null

    function createTestUtils() {

        "use strict"

        var console = (1, eval)("console")
        var path = require("path").posix

        /**
         * Wrapped logging function.
         * @param {string} msg The message to log.
         */
        var log = function(msg) {
            console.log(msg)
        };

        /**
         * Wrapped logging function.
         * @param {string} msg The message to log.
         */
        var error = function(msg) {
            console.log(msg)
        };

        /**
         * Turn off all logging.
         */
        var loggingOff = function() {
            log = function() {};
            error = function() {};
        };

        /**
         * Converts a WebGL enum to a string
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} value The enum value.
         * @return {string} The enum as a string.
         */
        var glEnumToString = function(gl, value) {
            for (var p in gl) {
                if (gl[p] == value) {
                    return p;
                }
            }
            return "0x" + value.toString(16);
        };

        var lastError = "";

        /**
         * Returns the last compiler/linker error.
         * @return {string} The last compiler/linker error.
         */
        var getLastError = function() {
            return lastError;
        };

        /**
         * Whether a haystack ends with a needle.
         * @param {string} haystack String to search
         * @param {string} needle String to search for.
         * @param {boolean} True if haystack ends with needle.
         */
        var endsWith = function(haystack, needle) {
            return haystack.substr(haystack.length - needle.length) === needle;
        };

        /**
         * Whether a haystack starts with a needle.
         * @param {string} haystack String to search
         * @param {string} needle String to search for.
         * @param {boolean} True if haystack starts with needle.
         */
        var startsWith = function(haystack, needle) {
            return haystack.substr(0, needle.length) === needle;
        };

        /**
         * A vertex shader for a single texture.
         * @type {string}
         */
        var simpleTextureVertexShader = [
            'attribute vec4 vPosition;',
            'attribute vec2 texCoord0;',
            'varying vec2 texCoord;',
            'void main() {',
            '    gl_Position = vPosition;',
            '    texCoord = texCoord0;',
            '}'
        ].join('\n');

        /**
         * A fragment shader for a single texture.
         * @type {string}
         */
        var simpleTextureFragmentShader = [
            'precision mediump float;',
            'uniform sampler2D tex;',
            'varying vec2 texCoord;',
            'void main() {',
            '    gl_FragData[0] = texture2D(tex, texCoord);',
            '}'
        ].join('\n');

        /**
         * A vertex shader for a single texture.
         * @type {string}
         */
        var noTexCoordTextureVertexShader = [
            'attribute vec4 vPosition;',
            'varying vec2 texCoord;',
            'void main() {',
            '    gl_Position = vPosition;',
            '    texCoord = vPosition.xy * 0.5 + 0.5;',
            '}'
        ].join('\n');

        /**
         * A vertex shader for a uniform color.
         * @type {string}
         */
        var simpleColorVertexShader = [
            'attribute vec4 vPosition;',
            'void main() {',
            '    gl_Position = vPosition;',
            '}'
        ].join('\n');

        /**
         * A fragment shader for a uniform color.
         * @type {string}
         */
        var simpleColorFragmentShader = [
            'precision mediump float;',
            'uniform vec4 u_color;',
            'void main() {',
            '    gl_FragData[0] = u_color;',
            '}'
        ].join('\n');

        /**
         * A vertex shader for vertex colors.
         * @type {string}
         */
        var simpleVertexColorVertexShader = [
            'attribute vec4 vPosition;',
            'attribute vec4 a_color;',
            'varying vec4 v_color;',
            'void main() {',
            '    gl_Position = vPosition;',
            '    v_color = a_color;',
            '}'
        ].join('\n');

        /**
         * A fragment shader for vertex colors.
         * @type {string}
         */
        var simpleVertexColorFragmentShader = [
            'precision mediump float;',
            'varying vec4 v_color;',
            'void main() {',
            '    gl_FragData[0] = v_color;',
            '}'
        ].join('\n');

        /**
         * Creates a simple texture vertex shader.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {!WebGLShader}
         */
        var setupSimpleTextureVertexShader = function(gl) {
            return loadShader(gl, simpleTextureVertexShader, gl.VERTEX_SHADER);
        };

        /**
         * Creates a simple texture fragment shader.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {!WebGLShader}
         */
        var setupSimpleTextureFragmentShader = function(gl) {
            return loadShader(
                gl, simpleTextureFragmentShader, gl.FRAGMENT_SHADER);
        };

        /**
         * Creates a texture vertex shader that doesn't need texcoords.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {!WebGLShader}
         */
        var setupNoTexCoordTextureVertexShader = function(gl) {
            return loadShader(gl, noTexCoordTextureVertexShader, gl.VERTEX_SHADER);
        };

        /**
         * Creates a simple vertex color vertex shader.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {!WebGLShader}
         */
        var setupSimpleVertexColorVertexShader = function(gl) {
            return loadShader(gl, simpleVertexColorVertexShader, gl.VERTEX_SHADER);
        };

        /**
         * Creates a simple vertex color fragment shader.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {!WebGLShader}
         */
        var setupSimpleVertexColorFragmentShader = function(gl) {
            return loadShader(
                gl, simpleVertexColorFragmentShader, gl.FRAGMENT_SHADER);
        };

        /**
         * Creates a simple color vertex shader.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {!WebGLShader}
         */
        var setupSimpleColorVertexShader = function(gl) {
            return loadShader(gl, simpleColorVertexShader, gl.VERTEX_SHADER);
        };

        /**
         * Creates a simple color fragment shader.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {!WebGLShader}
         */
        var setupSimpleColorFragmentShader = function(gl) {
            return loadShader(
                gl, simpleColorFragmentShader, gl.FRAGMENT_SHADER);
        };

        /**
         * Creates a program, attaches shaders, binds attrib locations, links the
         * program and calls useProgram.
         * @param {!Array.<!WebGLShader|string>} shaders The shaders to
         *        attach, or the source, or the id of a script to get
         *        the source from.
         * @param {!Array.<string>} opt_attribs The attribs names.
         * @param {!Array.<number>} opt_locations The locations for the attribs.
         */
        var setupProgram = function(gl, shaders, opt_attribs, opt_locations) {
            var realShaders = [];
            var program = gl.createProgram();
            var shaderType = undefined;
            for (var ii = 0; ii < shaders.length; ++ii) {
                var shader = shaders[ii];
                if (typeof shader == 'string') {
                    var element = ENVIRONMENT.scriptList[shader];
                    if (element) {
                        if (element.type != "x-shader/x-vertex" && element.type != "x-shader/x-fragment")
                            shaderType = ii ? gl.FRAGMENT_SHADER : gl.VERTEX_SHADER;
                        shader = loadShaderFromScript(gl, shader, shaderType);
                    } else if (endsWith(shader, ".vert")) {
                        shader = loadShaderFromFile(gl, shader, gl.VERTEX_SHADER);
                    } else if (endsWith(shader, ".frag")) {
                        shader = loadShaderFromFile(gl, shader, gl.FRAGMENT_SHADER);
                    } else {
                        shader = loadShader(gl, shader, ii ? gl.FRAGMENT_SHADER : gl.VERTEX_SHADER);
                    }
                }
                gl.attachShader(program, shader);
            }
            if (opt_attribs) {
                for (var ii = 0; ii < opt_attribs.length; ++ii) {
                    gl.bindAttribLocation(
                        program,
                        opt_locations ? opt_locations[ii] : ii,
                        opt_attribs[ii]);
                }
            }
            gl.linkProgram(program);

            // Check the link status
            var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!linked) {
                // something went wrong with the link
                lastError = gl.getProgramInfoLog(program);
                error("Error in program linking:" + lastError);

                gl.deleteProgram(program);
                return null;
            }

            gl.useProgram(program);
            return program;
        };

        /**
         * Creates a simple texture program.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} opt_positionLocation The attrib location for position.
         * @param {number} opt_texcoordLocation The attrib location for texture coords.
         * @return {WebGLProgram}
         */
        var setupSimpleTextureProgram = function(
            gl, opt_positionLocation, opt_texcoordLocation) {
            opt_positionLocation = opt_positionLocation || 0;
            opt_texcoordLocation = opt_texcoordLocation || 1;
            var vs = setupSimpleTextureVertexShader(gl);
            var fs = setupSimpleTextureFragmentShader(gl);
            if (!vs || !fs) {
                return null;
            }
            var program = setupProgram(
                gl, [vs, fs], ['vPosition', 'texCoord0'], [opt_positionLocation, opt_texcoordLocation]);
            if (!program) {
                gl.deleteShader(fs);
                gl.deleteShader(vs);
            }
            gl.useProgram(program);
            return program;
        };

        /**
         * Creates a simple texture program.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {WebGLProgram}
         */
        var setupNoTexCoordTextureProgram = function(gl) {
            var vs = setupNoTexCoordTextureVertexShader(gl);
            var fs = setupSimpleTextureFragmentShader(gl);
            if (!vs || !fs) {
                return null;
            }
            var program = setupProgram(
                gl, [vs, fs], ['vPosition'], [0]);
            if (!program) {
                gl.deleteShader(fs);
                gl.deleteShader(vs);
            }
            gl.useProgram(program);
            return program;
        };

        /**
         * Creates a simple texture program.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} opt_positionLocation The attrib location for position.
         * @param {number} opt_texcoordLocation The attrib location for texture coords.
         * @return {WebGLProgram}
         */
        var setupSimpleTextureProgram = function(
            gl, opt_positionLocation, opt_texcoordLocation) {
            opt_positionLocation = opt_positionLocation || 0;
            opt_texcoordLocation = opt_texcoordLocation || 1;
            var vs = setupSimpleTextureVertexShader(gl);
            var fs = setupSimpleTextureFragmentShader(gl);
            if (!vs || !fs) {
                return null;
            }
            var program = setupProgram(
                gl, [vs, fs], ['vPosition', 'texCoord0'], [opt_positionLocation, opt_texcoordLocation]);
            if (!program) {
                gl.deleteShader(fs);
                gl.deleteShader(vs);
            }
            gl.useProgram(program);
            return program;
        };

        /**
         * Creates a simple vertex color program.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} opt_positionLocation The attrib location for position.
         * @param {number} opt_vertexColorLocation The attrib location
         *        for vertex colors.
         * @return {WebGLProgram}
         */
        var setupSimpleVertexColorProgram = function(
            gl, opt_positionLocation, opt_vertexColorLocation) {
            opt_positionLocation = opt_positionLocation || 0;
            opt_vertexColorLocation = opt_vertexColorLocation || 1;
            var vs = setupSimpleVertexColorVertexShader(gl);
            var fs = setupSimpleVertexColorFragmentShader(gl);
            if (!vs || !fs) {
                return null;
            }
            var program = setupProgram(
                gl, [vs, fs], ['vPosition', 'a_color'], [opt_positionLocation, opt_vertexColorLocation]);
            if (!program) {
                gl.deleteShader(fs);
                gl.deleteShader(vs);
            }
            gl.useProgram(program);
            return program;
        };

        /**
         * Creates a simple color program.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} opt_positionLocation The attrib location for position.
         * @return {WebGLProgram}
         */
        var setupSimpleColorProgram = function(gl, opt_positionLocation) {
            opt_positionLocation = opt_positionLocation || 0;
            var vs = setupSimpleColorVertexShader(gl);
            var fs = setupSimpleColorFragmentShader(gl);
            if (!vs || !fs) {
                return null;
            }
            var program = setupProgram(
                gl, [vs, fs], ['vPosition'], [opt_positionLocation]);
            if (!program) {
                gl.deleteShader(fs);
                gl.deleteShader(vs);
            }
            gl.useProgram(program);
            return program;
        };

        /**
         * Creates buffers for a textured unit quad and attaches them to vertex attribs.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {number} opt_positionLocation The attrib location for position.
         * @param {number} opt_texcoordLocation The attrib location for texture coords.
         * @return {!Array.<WebGLBuffer>} The buffer objects that were
         *      created.
         */
        var setupUnitQuad = function(gl, opt_positionLocation, opt_texcoordLocation) {
            return setupUnitQuadWithTexCoords(gl, [0.0, 0.0], [1.0, 1.0],
                opt_positionLocation, opt_texcoordLocation);
        };

        /**
         * Creates buffers for a textured unit quad with specified lower left
         * and upper right texture coordinates, and attaches them to vertex
         * attribs.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {!Array.<number>} lowerLeftTexCoords The texture coordinates for the lower left corner.
         * @param {!Array.<number>} upperRightTexCoords The texture coordinates for the upper right corner.
         * @param {number} opt_positionLocation The attrib location for position.
         * @param {number} opt_texcoordLocation The attrib location for texture coords.
         * @return {!Array.<WebGLBuffer>} The buffer objects that were
         *      created.
         */
        var setupUnitQuadWithTexCoords = function(
            gl, lowerLeftTexCoords, upperRightTexCoords,
            opt_positionLocation, opt_texcoordLocation) {
            return setupQuad(gl, {
                positionLocation: opt_positionLocation || 0,
                texcoordLocation: opt_texcoordLocation || 1,
                lowerLeftTexCoords: lowerLeftTexCoords,
                upperRightTexCoords: upperRightTexCoords,
            });
        };

        /**
         * Makes a quad with various options.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {!Object} options.
         *
         * scale: scale to multiple unit quad values by. default 1.0.
         * positionLocation: attribute location for position.
         * texcoordLocation: attribute location for texcoords.
         *     If this does not exist no texture coords are created.
         * lowerLeftTexCoords: an array of 2 values for the
         *     lowerLeftTexCoords.
         * upperRightTexCoords: an array of 2 values for the
         *     upperRightTexCoords.
         */
        var setupQuad = function(gl, options) {
            var positionLocation = options.positionLocation || 0;
            var scale = options.scale || 1;

            var objects = [];

            var vertexObject = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexObject);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                1.0 * scale, 1.0 * scale, -1.0 * scale, 1.0 * scale, -1.0 * scale, -1.0 * scale,
                1.0 * scale, 1.0 * scale, -1.0 * scale, -1.0 * scale,
                1.0 * scale, -1.0 * scale,
            ]), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            objects.push(vertexObject);

            if (options.texcoordLocation !== undefined) {
                var llx = options.lowerLeftTexCoords[0];
                var lly = options.lowerLeftTexCoords[1];
                var urx = options.upperRightTexCoords[0];
                var ury = options.upperRightTexCoords[1];

                var vertexObject = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexObject);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    urx, ury,
                    llx, ury,
                    llx, lly,
                    urx, ury,
                    llx, lly,
                    urx, lly
                ]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(options.texcoordLocation);
                gl.vertexAttribPointer(options.texcoordLocation, 2, gl.FLOAT, false, 0, 0);
                objects.push(vertexObject);
            }

            return objects;
        };

        /**
         * Creates a program and buffers for rendering a textured quad.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {number} opt_positionLocation The attrib location for
         *        position. Default = 0.
         * @param {number} opt_texcoordLocation The attrib location for
         *        texture coords. Default = 1.
         * @return {!WebGLProgram}
         */
        var setupTexturedQuad = function(
            gl, opt_positionLocation, opt_texcoordLocation) {
            var program = setupSimpleTextureProgram(
                gl, opt_positionLocation, opt_texcoordLocation);
            setupUnitQuad(gl, opt_positionLocation, opt_texcoordLocation);
            return program;
        };

        /**
         * Creates a program and buffers for rendering a color quad.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {number} opt_positionLocation The attrib location for position.
         * @return {!WebGLProgram}
         */
        var setupColorQuad = function(gl, opt_positionLocation) {
            opt_positionLocation = opt_positionLocation || 0;
            var program = setupSimpleColorProgram(gl);
            setupUnitQuad(gl, opt_positionLocation);
            return program;
        };

        /**
         * Creates a program and buffers for rendering a textured quad with
         * specified lower left and upper right texture coordinates.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {!Array.<number>} lowerLeftTexCoords The texture coordinates for the lower left corner.
         * @param {!Array.<number>} upperRightTexCoords The texture coordinates for the upper right corner.
         * @param {number} opt_positionLocation The attrib location for position.
         * @param {number} opt_texcoordLocation The attrib location for texture coords.
         * @return {!WebGLProgram}
         */
        var setupTexturedQuadWithTexCoords = function(
            gl, lowerLeftTexCoords, upperRightTexCoords,
            opt_positionLocation, opt_texcoordLocation) {
            var program = setupSimpleTextureProgram(
                gl, opt_positionLocation, opt_texcoordLocation);
            setupUnitQuadWithTexCoords(gl, lowerLeftTexCoords, upperRightTexCoords,
                opt_positionLocation, opt_texcoordLocation);
            return program;
        };

        /**
         * Creates a unit quad with only positions of a given resolution.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {number} gridRes The resolution of the mesh grid,
         *     expressed in the number of quads across and down.
         * @param {number} opt_positionLocation The attrib location for position.
         */
        var setupIndexedQuad = function(
            gl, gridRes, opt_positionLocation, opt_flipOddTriangles) {
            return setupIndexedQuadWithOptions(gl, {
                gridRes: gridRes,
                positionLocation: opt_positionLocation,
                flipOddTriangles: opt_flipOddTriangles
            });
        };

        /**
         * Creates a quad with various options.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {!Object) options The options. See below.
         * @return {!Array.<WebGLBuffer>} The created buffers.
         *     [positions, <colors>, indices]
         *
         * Options:
         *   gridRes: number of quads across and down grid.
         *   positionLocation: attrib location for position
         *   flipOddTriangles: reverse order of vertices of every other
         *       triangle
         *   positionOffset: offset added to each vertex
         *   positionMult: multipier for each vertex
         *   colorLocation: attrib location for vertex colors. If
         *      undefined no vertex colors will be created.
         */
        var setupIndexedQuadWithOptions = function(gl, options) {
            var positionLocation = options.positionLocation || 0;
            var objects = [];

            var gridRes = options.gridRes || 1;
            var positionOffset = options.positionOffset || 0;
            var positionMult = options.positionMult || 1;
            var vertsAcross = gridRes + 1;
            var numVerts = vertsAcross * vertsAcross;
            var positions = new Float32Array(numVerts * 3);
            var indices = new Uint16Array(6 * gridRes * gridRes);
            var poffset = 0;

            for (var yy = 0; yy <= gridRes; ++yy) {
                for (var xx = 0; xx <= gridRes; ++xx) {
                    positions[poffset + 0] = (-1 + 2 * xx / gridRes) * positionMult + positionOffset;
                    positions[poffset + 1] = (-1 + 2 * yy / gridRes) * positionMult + positionOffset;
                    positions[poffset + 2] = 0;

                    poffset += 3;
                }
            }

            var buf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
            objects.push(buf);

            if (options.colorLocation !== undefined) {
                var colors = new Float32Array(numVerts * 4);
                for (var yy = 0; yy <= gridRes; ++yy) {
                    for (var xx = 0; xx <= gridRes; ++xx) {
                        if (options.color !== undefined) {
                            colors[poffset + 0] = options.color[0];
                            colors[poffset + 1] = options.color[1];
                            colors[poffset + 2] = options.color[2];
                            colors[poffset + 3] = options.color[3];
                        } else {
                            colors[poffset + 0] = xx / gridRes;
                            colors[poffset + 1] = yy / gridRes;
                            colors[poffset + 2] = (xx / gridRes) * (yy / gridRes);
                            colors[poffset + 3] = (yy % 2) * 0.5 + 0.5;
                        }
                        poffset += 4;
                    }
                }

                var buf = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(options.colorLocation);
                gl.vertexAttribPointer(options.colorLocation, 4, gl.FLOAT, false, 0, 0);
                objects.push(buf);
            }

            var tbase = 0;
            for (var yy = 0; yy < gridRes; ++yy) {
                var index = yy * vertsAcross;
                for (var xx = 0; xx < gridRes; ++xx) {
                    indices[tbase + 0] = index + 0;
                    indices[tbase + 1] = index + 1;
                    indices[tbase + 2] = index + vertsAcross;
                    indices[tbase + 3] = index + vertsAcross;
                    indices[tbase + 4] = index + 1;
                    indices[tbase + 5] = index + vertsAcross + 1;

                    if (options.flipOddTriangles) {
                        indices[tbase + 4] = index + vertsAcross + 1;
                        indices[tbase + 5] = index + 1;
                    }

                    index += 1;
                    tbase += 6;
                }
            }

            var buf = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            objects.push(buf);

            return objects;
        };

        /**
         * Fills the given texture with a solid color
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!WebGLTexture} tex The texture to fill.
         * @param {number} width The width of the texture to create.
         * @param {number} height The height of the texture to create.
         * @param {!Array.<number>} color The color to fill with. A 4 element array
         *        where each element is in the range 0 to 255.
         * @param {number} opt_level The level of the texture to fill. Default = 0.
         */
        var fillTexture = function(gl, tex, width, height, color, opt_level) {
            opt_level = opt_level || 0;
            var numPixels = width * height;
            var size = numPixels * 4;
            var buf = new Uint8Array(size);
            for (var ii = 0; ii < numPixels; ++ii) {
                var off = ii * 4;
                buf[off + 0] = color[0];
                buf[off + 1] = color[1];
                buf[off + 2] = color[2];
                buf[off + 3] = color[3];
            }
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(
                gl.TEXTURE_2D, opt_level, gl.RGBA, width, height, 0,
                gl.RGBA, gl.UNSIGNED_BYTE, buf);
        };

        /**
         * Creates a textures and fills it with a solid color
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} width The width of the texture to create.
         * @param {number} height The height of the texture to create.
         * @param {!Array.<number>} color The color to fill with. A 4 element array
         *        where each element is in the range 0 to 255.
         * @return {!WebGLTexture}
         */
        var createColoredTexture = function(gl, width, height, color) {
            var tex = gl.createTexture();
            fillTexture(gl, tex, width, height, color);
            return tex;
        };

        var ubyteToFloat = function(c) {
            return c / 255;
        };

        var ubyteColorToFloatColor = function(color) {
            var floatColor = [];
            for (var ii = 0; ii < color.length; ++ii) {
                floatColor[ii] = ubyteToFloat(color[ii]);
            }
            return floatColor;
        };

        /**
         * Sets the "u_color" uniform of the current program to color.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!Array.<number> color 4 element array of 0-1 color
         *      components.
         */
        var setFloatDrawColor = function(gl, color) {
            var program = gl.getParameter(gl.CURRENT_PROGRAM);
            var colorLocation = gl.getUniformLocation(program, "u_color");
            gl.uniform4fv(colorLocation, color);
        };

        /**
         * Sets the "u_color" uniform of the current program to color.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!Array.<number> color 4 element array of 0-255 color
         *      components.
         */
        var setUByteDrawColor = function(gl, color) {
            setFloatDrawColor(gl, ubyteColorToFloatColor(color));
        };

        /**
         * Draws a previously setup quad in the given color.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!Array.<number>} color The color to draw with. A 4
         *        element array where each element is in the range 0 to
         *        1.
         */
        var drawFloatColorQuad = function(gl, color) {
            var program = gl.getParameter(gl.CURRENT_PROGRAM);
            var colorLocation = gl.getUniformLocation(program, "u_color");
            gl.uniform4fv(colorLocation, color);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        };


        /**
         * Draws a previously setup quad in the given color.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!Array.<number>} color The color to draw with. A 4
         *        element array where each element is in the range 0 to
         *        255.
         */
        var drawUByteColorQuad = function(gl, color) {
            drawFloatColorQuad(gl, ubyteColorToFloatColor(color));
        };

        /**
         * Draws a previously setupUnitQuad.
         * @param {!WebGLContext} gl The WebGLContext to use.
         */
        var drawUnitQuad = function(gl) {
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        };

        /**
         * Clears then Draws a previously setupUnitQuad.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!Array.<number>} opt_color The color to fill clear with before
         *        drawing. A 4 element array where each element is in the range 0 to
         *        255. Default [255, 255, 255, 255]
         */
        var clearAndDrawUnitQuad = function(gl, opt_color) {
            opt_color = opt_color || [255, 255, 255, 255];
            gl.clearColor(
                opt_color[0] / 255,
                opt_color[1] / 255,
                opt_color[2] / 255,
                opt_color[3] / 255);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            drawUnitQuad(gl);
        };

        /**
         * Draws a quad previsouly settup with setupIndexedQuad.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} gridRes Resolution of grid.
         */
        var drawIndexedQuad = function(gl, gridRes) {
            gl.drawElements(gl.TRIANGLES, gridRes * gridRes * 6, gl.UNSIGNED_SHORT, 0);
        };

        /**
         * Draws a previously setupIndexedQuad
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} gridRes Resolution of grid.
         * @param {!Array.<number>} opt_color The color to fill clear with before
         *        drawing. A 4 element array where each element is in the range 0 to
         *        255. Default [255, 255, 255, 255]
         */
        var clearAndDrawIndexedQuad = function(gl, gridRes, opt_color) {
            opt_color = opt_color || [255, 255, 255, 255];
            gl.clearColor(
                opt_color[0] / 255,
                opt_color[1] / 255,
                opt_color[2] / 255,
                opt_color[3] / 255);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            drawIndexedQuad(gl, gridRes);
        };

        /**
         * Checks that a portion of a canvas is 1 color.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} x left corner of region to check.
         * @param {number} y bottom corner of region to check.
         * @param {number} width width of region to check.
         * @param {number} height width of region to check.
         * @param {!Array.<number>} color The color to fill clear with before drawing. A
         *        4 element array where each element is in the range 0 to 255.
         * @param {number} opt_errorRange Optional. Acceptable error in
         *        color checking. 0 by default.
         * @param {!function()} sameFn Function to call if all pixels
         *        are the same as color.
         * @param {!function()} differentFn Function to call if a pixel
         *        is different than color
         * @param {!function()} logFn Function to call for logging.
         */
        var checkCanvasRectColor = function(gl, x, y, width, height, color, opt_errorRange, sameFn, differentFn, logFn) {
            var errorRange = opt_errorRange || 0;
            if (!errorRange.length) {
                errorRange = [errorRange, errorRange, errorRange, errorRange]
            }
            var buf;
            if (gl instanceof WebGLRenderingContext) {
                buf = new Uint8Array(width * height * 4);
                gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, buf);
            } else {
                buf = gl.getImageData(x, y, width, height).data;
            }
            for (var i = 0; i < width * height; ++i) {
                var offset = i * 4;
                for (var j = 0; j < color.length; ++j) {
                    if (Math.abs(buf[offset + j] - color[j]) > errorRange[j]) {
                        differentFn();
                        var was = buf[offset + 0].toString();
                        for (j = 1; j < color.length; ++j) {
                            was += "," + buf[offset + j];
                        }
                        logFn('at (' + (x + (i % width)) + ', ' + (y + Math.floor(i / width)) +
                            ') expected: ' + color + ' was ' + was);
                        return;
                    }
                }
            }
            sameFn();
        };

        /**
         * Checks that a portion of a canvas is 1 color.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} x left corner of region to check.
         * @param {number} y bottom corner of region to check.
         * @param {number} width width of region to check.
         * @param {number} height width of region to check.
         * @param {!Array.<number>} color The color to fill clear with before drawing. A
         *        4 element array where each element is in the range 0 to 255.
         * @param {string} opt_msg Message to associate with success. Eg
         *        ("should be red").
         * @param {number} opt_errorRange Optional. Acceptable error in
         *        color checking. 0 by default.
         */
        var checkCanvasRect = function(gl, x, y, width, height, color, opt_msg, opt_errorRange) {
            var msg = opt_msg;
            if (msg === undefined) {
                msg = "should be " + color.toString();
            }
            checkCanvasRectColor(
                gl, x, y, width, height, color, opt_errorRange,
                function() {
                    testPassed(msg);
                },
                function() {
                    testFailed(msg);
                },
                debug);
        };

        /**
         * Checks a rectangular area both inside the area and outside
         * the area.
         * @param {!WebGLRenderingContext|CanvasRenderingContext2D} gl The
         *         WebGLRenderingContext or 2D context to use.
         * @param {number} x left corner of region to check.
         * @param {number} y bottom corner of region to check in case of checking from
         *        a GL context or top corner in case of checking from a 2D context.
         * @param {number} width width of region to check.
         * @param {number} height width of region to check.
         * @param {!Array.<number>} innerColor The color expected inside
         *     the area. A 4 element array where each element is in the
         *     range 0 to 255.
         * @param {!Array.<number>} outerColor The color expected
         *     outside. A 4 element array where each element is in the
         *     range 0 to 255.
         * @param {!number} opt_edgeSize: The number of pixels to skip
         *     around the edges of the area. Defaut 0.
         * @param {!{width:number, height:number}} opt_outerDimensions
         *     The outer dimensions. Default the size of gl.canvas.
         */
        var checkAreaInAndOut = function(gl, x, y, width, height, innerColor, outerColor, opt_edgeSize, opt_outerDimensions) {
            var outerDimensions = opt_outerDimensions || {
                width: gl.canvas.width,
                height: gl.canvas.height
            };
            var edgeSize = opt_edgeSize || 0;
            checkCanvasRect(gl, x + edgeSize, y + edgeSize, width - edgeSize * 2, height - edgeSize * 2, innerColor);
            checkCanvasRect(gl, 0, 0, x - edgeSize, outerDimensions.height, outerColor);
            checkCanvasRect(gl, x + width + edgeSize, 0, outerDimensions.width - x - width - edgeSize, outerDimensions.height, outerColor);
            checkCanvasRect(gl, 0, 0, outerDimensions.width, y - edgeSize, outerColor);
            checkCanvasRect(gl, 0, y + height + edgeSize, outerDimensions.width, outerDimensions.height - y - height - edgeSize, outerColor);
        };


        /**
         * Checks that an entire canvas is 1 color.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!Array.<number>} color The color to fill clear with before drawing. A
         *        4 element array where each element is in the range 0 to 255.
         * @param {string} msg Message to associate with success. Eg ("should be red").
         * @param {number} errorRange Optional. Acceptable error in
         *        color checking. 0 by default.
         */
        var checkCanvas = function(gl, color, msg, errorRange) {
            checkCanvasRect(gl, 0, 0, gl.canvas.width, gl.canvas.height, color, msg, errorRange);
        };

        /**
         * Loads a texture, calls callback when finished.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} url URL of image to load
         * @param {function(!Image): void} callback Function that gets called after
         *        image has loaded
         * @return {!WebGLTexture} The created texture.
         */
        var loadTexture = function(gl, url, callback) {
            var texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            var image = new Image();
            image.onload = function() {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                callback(image);
            };
            image.src = url;
            return texture;
        };

        /**
         * Makes a shallow copy of an object.
         * @param {!Object) src Object to copy
         * @return {!Object} The copy of src.
         */
        var shallowCopyObject = function(src) {
            var dst = {};
            for (var attr in src) {
                if (src.hasOwnProperty(attr)) {
                    dst[attr] = src[attr];
                }
            }
            return dst;
        };

        /**
         * Checks if an attribute exists on an object case insensitive.
         * @param {!Object) obj Object to check
         * @param {string} attr Name of attribute to look for.
         * @return {string?} The name of the attribute if it exists,
         *         undefined if not.
         */
        var hasAttributeCaseInsensitive = function(obj, attr) {
            var lower = attr.toLowerCase();
            for (var key in obj) {
                if (obj.hasOwnProperty(key) && key.toLowerCase() == lower) {
                    return key;
                }
            }
        };

        /**
         * Returns a map of URL querystring options
         * @return {Object?} Object containing all the values in the URL querystring
         */
        var getUrlOptions = function() {
            return {}
        };

        /**
         * Creates a webgl context.
         * @param {!Canvas|string} opt_canvas The canvas tag to get
         *     context from. If one is not passed in one will be
         *     created. If it's a string it's assumed to be the id of a
         *     canvas.
         * @return {!WebGLContext} The created context.
         */
        var create3DContext = function(opt_canvas, opt_attributes) {
            var width = 500
            var height = 500
            if (opt_canvas) {
                if (typeof opt_canvas === 'string') {
                    var canvasList = ENVIRONMENT.canvasList
                    for (var i = 0; i < canvasList.length; ++i) {
                        if (canvasList[i].id === opt_canvas) {
                            width = canvasList[i].width || 500
                            height = canvasList[i].height || 500
                            var ctx = ENVIRONMENT.createContext(width, height, opt_attributes)
                            ctx.canvas = canvasList[i]
                            ctx.canvas._gl = ctx
                            canvas = ctx.canvas
                            return ctx
                        }
                    }
                } else {
                    width = opt_canvas.width || 512
                    height = opt_canvas.height || 512
                    var ctx = ENVIRONMENT.createContext(width, height, opt_attributes)
                    ctx.canvas = opt_canvas
                    ctx.canvas._gl = ctx
                    canvas = ctx.canvas
                    return ctx
                }
            }
            var ctx = ENVIRONMENT.createContext(width, height, opt_attributes)
            canvas = document.createElement("canvas")
            ctx.canvas = canvas
            ctx.canvas._gl = ctx
            return ctx
        }

        /**
         * Gets a GLError value as a string.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} err The webgl error as retrieved from gl.getError().
         * @return {string} the error as a string.
         */
        var getGLErrorAsString = function(gl, err) {
            if (err === gl.NO_ERROR) {
                return "NO_ERROR";
            }
            for (var name in gl) {
                if (gl[name] === err) {
                    return name;
                }
            }
            return err.toString();
        };

        /**
         * Wraps a WebGL function with a function that throws an exception if there is
         * an error.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} fname Name of function to wrap.
         * @return {function} The wrapped function.
         */
        var createGLErrorWrapper = function(context, fname) {
            return function() {
                var rv = context[fname].apply(context, arguments);
                var err = context.getError();
                if (err != context.NO_ERROR)
                    throw "GL error " + getGLErrorAsString(context, err) + " in " + fname;
                return rv;
            };
        };

        /**
         * Creates a WebGL context where all functions are wrapped to throw an exception
         * if there is an error.
         * @param {!Canvas} canvas The HTML canvas to get a context from.
         * @return {!Object} The wrapped context.
         */
        function create3DContextWithWrapperThatThrowsOnGLError(canvas) {
            var context = create3DContext(canvas);
            var wrap = {};
            for (var i in context) {
                try {
                    if (typeof context[i] == 'function') {
                        wrap[i] = createGLErrorWrapper(context, i);
                    } else {
                        wrap[i] = context[i];
                    }
                } catch (e) {
                    error("createContextWrapperThatThrowsOnGLError: Error accessing " + i);
                }
            }
            wrap.getError = function() {
                return context.getError();
            };
            return wrap;
        };

        /**
         * Tests that an evaluated expression generates a specific GL error.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} glError The expected gl error.
         * @param {string} evalSTr The string to evaluate.
         */
        var shouldGenerateGLError = function(gl, glError, evalStr) {
            var exception;
            try {
                eval(evalStr);
            } catch (e) {
                exception = e;
            }
            if (exception) {
                testFailed(evalStr + " threw exception " + exception);
            } else {
                var err = gl.getError();
                if (err != glError) {
                    testFailed(evalStr + " expected: " + getGLErrorAsString(gl, glError) + ". Was " + getGLErrorAsString(gl, err) + ".");
                } else {
                    testPassed(evalStr + " was expected value: " + getGLErrorAsString(gl, glError) + ".");
                }
            }
        };

        /**
         * Tests that the first error GL returns is the specified error.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} glError The expected gl error.
         * @param {string} opt_msg
         */
        var glErrorShouldBe = function(gl, glErrors, opt_msg) {
            if (!glErrors.length) {
                glErrors = [glErrors];
            }
            opt_msg = opt_msg || "";
            var err = gl.getError();
            var ndx = glErrors.indexOf(err);
            var errStrs = [];
            for (var ii = 0; ii < glErrors.length; ++ii) {
                errStrs.push(glEnumToString(gl, glErrors[ii]));
            }
            var expected = errStrs.join(" or ");
            if (ndx < 0) {
                var msg = "getError expected" + ((glErrors.length > 1) ? " one of: " : ": ");
                testFailed(msg + expected + ". Was " + glEnumToString(gl, err) + " : " + opt_msg);
            } else {
                var msg = "getError was " + ((glErrors.length > 1) ? "one of: " : "expected value: ");
                testPassed(msg + expected + " : " + opt_msg);
            }
        };

        /**
         * Links a WebGL program, throws if there are errors.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!WebGLProgram} program The WebGLProgram to link.
         * @param {function(string): void) opt_errorCallback callback for errors.
         */
        var linkProgram = function(gl, program, opt_errorCallback) {
            var errFn = opt_errorCallback || testFailed;
            // Link the program
            gl.linkProgram(program);

            // Check the link status
            var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!linked) {
                // something went wrong with the link
                var error = gl.getProgramInfoLog(program);

                errFn("Error in program linking:" + error);

                gl.deleteProgram(program);
            }
        };

        /**
         * Loads text from an external file. This function is synchronous.
         * @param {string} url The url of the external file.
         * @param {!function(bool, string): void} callback that is sent a bool for
         *     success and the string.
         */
        var loadTextFileAsync = function(url, callback) {
            setTimeout(function() {
                var file = ENVIRONMENT.RESOURCES[path.join(ENVIRONMENT.BASEPATH, url)]
                if (file) {
                    var buf = new Buffer(file, 'base64')
                    callback(true, buf.toString())
                } else {
                    throw new Error('error loading file: ' + url)
                }
            }, 1)
        };

        /**
         * Recursively loads a file as a list. Each line is parsed for a relative
         * path. If the file ends in .txt the contents of that file is inserted in
         * the list.
         *
         * @param {string} url The url of the external file.
         * @param {!function(bool, Array<string>): void} callback that is sent a bool
         *     for success and the array of strings.
         */
        var getFileListAsync = function(url, callback) {
            var files = [];

            var getFileListImpl = function(url, callback) {
                var files = [];
                if (url.substr(url.length - 4) == '.txt') {
                    loadTextFileAsync(url, function() {
                        return function(success, text) {
                            if (!success) {
                                callback(false, '');
                                return;
                            }
                            var lines = text.split('\n');
                            var prefix = '';
                            var lastSlash = url.lastIndexOf('/');
                            if (lastSlash >= 0) {
                                prefix = url.substr(0, lastSlash + 1);
                            }
                            var fail = false;
                            var count = 1;
                            var index = 0;
                            for (var ii = 0; ii < lines.length; ++ii) {
                                var str = lines[ii].replace(/^\s\s*/, '').replace(/\s\s*$/, '');
                                if (str.length > 4 &&
                                    str[0] != '#' &&
                                    str[0] != ";" &&
                                    str.substr(0, 2) != "//") {
                                    var names = str.split(/ +/);
                                    new_url = prefix + str;
                                    if (names.length == 1) {
                                        new_url = prefix + str;
                                        ++count;
                                        getFileListImpl(new_url, function(index) {
                                            return function(success, new_files) {
                                                log("got files: " + new_files.length);
                                                if (success) {
                                                    files[index] = new_files;
                                                }
                                                finish(success);
                                            };
                                        }(index++));
                                    } else {
                                        var s = "";
                                        var p = "";
                                        for (var jj = 0; jj < names.length; ++jj) {
                                            s += p + prefix + names[jj];
                                            p = " ";
                                        }
                                        files[index++] = s;
                                    }
                                }
                            }
                            finish(true);

                            function finish(success) {
                                if (!success) {
                                    fail = true;
                                }
                                --count;
                                log("count: " + count);
                                if (!count) {
                                    callback(!fail, files);
                                }
                            }
                        }
                    }());

                } else {
                    files.push(url);
                    callback(true, files);
                }
            };

            getFileListImpl(url, function(success, files) {
                // flatten
                var flat = [];
                flatten(files);

                function flatten(files) {
                    for (var ii = 0; ii < files.length; ++ii) {
                        var value = files[ii];
                        if (typeof(value) == "string") {
                            flat.push(value);
                        } else {
                            flatten(value);
                        }
                    }
                }
                callback(success, flat);
            });
        };

        /**
         * Gets a file from a file/URL
         * @param {string} file the URL of the file to get.
         * @return {string} The contents of the file.
         */
        var readFile = function(file) {
            var buf = new Buffer(ENVIRONMENT.RESOURCES[path.join('resources', file)], 'base64')
            var text = buf.toString()
            return text.replace(/\r/g, "");
        };

        var readFileList = function(url) {
            var files = [];
            if (url.substr(url.length - 4) == '.txt') {
                var lines = readFile(url).split('\n');
                var prefix = '';
                var lastSlash = url.lastIndexOf('/');
                if (lastSlash >= 0) {
                    prefix = url.substr(0, lastSlash + 1);
                }
                for (var ii = 0; ii < lines.length; ++ii) {
                    var str = lines[ii].replace(/^\s\s*/, '').replace(/\s\s*$/, '');
                    if (str.length > 4 &&
                        str[0] != '#' &&
                        str[0] != ";" &&
                        str.substr(0, 2) != "//") {
                        var names = str.split(/ +/);
                        if (names.length == 1) {
                            new_url = prefix + str;
                            files = files.concat(readFileList(new_url));
                        } else {
                            var s = "";
                            var p = "";
                            for (var jj = 0; jj < names.length; ++jj) {
                                s += p + prefix + names[jj];
                                p = " ";
                            }
                            files.push(s);
                        }
                    }
                }
            } else {
                files.push(url);
            }
            return files;
        };

        /**
         * Loads a shader.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} shaderSource The shader source.
         * @param {number} shaderType The type of shader.
         * @param {function(string): void) opt_errorCallback callback for errors.
         * @return {!WebGLShader} The created shader.
         */
        var loadShader = function(gl, shaderSource, shaderType, opt_errorCallback) {
            var errFn = opt_errorCallback || error;
            // Create the shader object
            var shader = gl.createShader(shaderType);
            if (shader == null) {
                errFn("*** Error: unable to create shader '" + shaderSource + "'");
                return null;
            }

            // Load the shader source
            gl.getError()
            gl.shaderSource(shader, shaderSource);
            var err = gl.getError();
            if (err != gl.NO_ERROR) {
                errFn("*** Error loading shader '" + shader + "':" + glEnumToString(gl, err));
                return null;
            }

            // Compile the shader
            gl.compileShader(shader);

            // Check the compile status
            var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!compiled) {
                // Something went wrong during compilation; get the error
                lastError = gl.getShaderInfoLog(shader);
                errFn("*** Error compiling " + glEnumToString(gl, shaderType) + " '" + shader + "':" + lastError);
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        /**
         * Loads a shader from a URL.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {file} file The URL of the shader source.
         * @param {number} type The type of shader.
         * @param {function(string): void) opt_errorCallback callback for errors.
         * @return {!WebGLShader} The created shader.
         */
        var loadShaderFromFile = function(gl, file, type, opt_errorCallback) {
            var shaderSource = readFile(file);
            return loadShader(gl, shaderSource, type, opt_errorCallback);
        };

        /**
         * Gets the content of script.
         */
        var getScript = function(scriptId) {
            var shaderScript = ENVIRONMENT.scriptList[scriptId];
            if (!shaderScript) {
                throw ("*** Error: unknown script element" + scriptId);
            }
            return shaderScript.text;
        };

        /**
         * Loads a shader from a script tag.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} scriptId The id of the script tag.
         * @param {number} opt_shaderType The type of shader. If not passed in it will
         *     be derived from the type of the script tag.
         * @param {function(string): void) opt_errorCallback callback for errors.
         * @return {!WebGLShader} The created shader.
         */
        var loadShaderFromScript = function(
            gl, scriptId, opt_shaderType, opt_errorCallback) {
            var shaderSource = "";
            var shaderType;
            var shaderScript = ENVIRONMENT.scriptList[scriptId];
            if (!shaderScript) {
                throw ("*** Error: unknown script element " + scriptId);
            }
            shaderSource = shaderScript.text;

            if (!opt_shaderType) {
                if (shaderScript.type == "x-shader/x-vertex") {
                    shaderType = gl.VERTEX_SHADER;
                } else if (shaderScript.type == "x-shader/x-fragment") {
                    shaderType = gl.FRAGMENT_SHADER;
                } else if (shaderType != gl.VERTEX_SHADER && shaderType != gl.FRAGMENT_SHADER) {
                    throw ("*** Error: unknown shader type");
                    return null;
                }
            }

            return loadShader(
                gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType,
                opt_errorCallback);
        };

        var loadStandardProgram = function(gl) {
            var program = gl.createProgram();
            gl.attachShader(program, loadStandardVertexShader(gl));
            gl.attachShader(program, loadStandardFragmentShader(gl));
            gl.bindAttribLocation(program, 0, "a_vertex");
            gl.bindAttribLocation(program, 1, "a_normal");
            linkProgram(gl, program);
            return program;
        };

        /**
         * Loads shaders from files, creates a program, attaches the shaders and links.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} vertexShaderPath The URL of the vertex shader.
         * @param {string} fragmentShaderPath The URL of the fragment shader.
         * @param {function(string): void) opt_errorCallback callback for errors.
         * @return {!WebGLProgram} The created program.
         */
        var loadProgramFromFile = function(
            gl, vertexShaderPath, fragmentShaderPath, opt_errorCallback) {
            var program = gl.createProgram();
            var vs = loadShaderFromFile(
                gl, vertexShaderPath, gl.VERTEX_SHADER, opt_errorCallback);
            var fs = loadShaderFromFile(
                gl, fragmentShaderPath, gl.FRAGMENT_SHADER, opt_errorCallback);
            if (vs && fs) {
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                linkProgram(gl, program, opt_errorCallback);
            }
            if (vs) {
                gl.deleteShader(vs);
            }
            if (fs) {
                gl.deleteShader(fs);
            }
            return program;
        };

        /**
         * Loads shaders from script tags, creates a program, attaches the shaders and
         * links.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} vertexScriptId The id of the script tag that contains the
         *        vertex shader.
         * @param {string} fragmentScriptId The id of the script tag that contains the
         *        fragment shader.
         * @param {function(string): void) opt_errorCallback callback for errors.
         * @return {!WebGLProgram} The created program.
         */
        var loadProgramFromScript = function loadProgramFromScript(
            gl, vertexScriptId, fragmentScriptId, opt_errorCallback) {
            var program = gl.createProgram();
            gl.attachShader(
                program,
                loadShaderFromScript(
                    gl, vertexScriptId, gl.VERTEX_SHADER, opt_errorCallback));
            gl.attachShader(
                program,
                loadShaderFromScript(
                    gl, fragmentScriptId, gl.FRAGMENT_SHADER, opt_errorCallback));
            linkProgram(gl, program, opt_errorCallback);
            return program;
        };

        /**
         * Loads shaders from source, creates a program, attaches the shaders and
         * links.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!WebGLShader} vertexShader The vertex shader.
         * @param {!WebGLShader} fragmentShader The fragment shader.
         * @param {function(string): void) opt_errorCallback callback for errors.
         * @return {!WebGLProgram} The created program.
         */
        var createProgram = function(gl, vertexShader, fragmentShader, opt_errorCallback) {
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            linkProgram(gl, program, opt_errorCallback);
            return program;
        };

        /**
         * Loads shaders from source, creates a program, attaches the shaders and
         * links.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} vertexShader The vertex shader source.
         * @param {string} fragmentShader The fragment shader source.
         * @param {function(string): void) opt_errorCallback callback for errors.
         * @return {!WebGLProgram} The created program.
         */
        var loadProgram = function(
            gl, vertexShader, fragmentShader, opt_errorCallback) {
            var program;
            var vs = loadShader(
                gl, vertexShader, gl.VERTEX_SHADER, opt_errorCallback);
            var fs = loadShader(
                gl, fragmentShader, gl.FRAGMENT_SHADER, opt_errorCallback);
            if (vs && fs) {
                program = createProgram(gl, vs, fs, opt_errorCallback)
            }
            if (vs) {
                gl.deleteShader(vs);
            }
            if (fs) {
                gl.deleteShader(fs);
            }
            return program;
        };

        /**
         * Loads shaders from source, creates a program, attaches the shaders and
         * links but expects error.
         *
         * GLSL 1.0.17 10.27 effectively says that compileShader can
         * always succeed as long as linkProgram fails so we can't
         * rely on compileShader failing. This function expects
         * one of the shader to fail OR linking to fail.
         *
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} vertexShaderScriptId The vertex shader.
         * @param {string} fragmentShaderScriptId The fragment shader.
         * @return {WebGLProgram} The created program.
         */
        var loadProgramFromScriptExpectError = function(
            gl, vertexShaderScriptId, fragmentShaderScriptId) {
            var vertexShader = loadShaderFromScript(gl, vertexShaderScriptId);
            if (!vertexShader) {
                return null;
            }
            var fragmentShader = loadShaderFromScript(gl, fragmentShaderScriptId);
            if (!fragmentShader) {
                return null;
            }
            var linkSuccess = true;
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            linkSuccess = true;
            linkProgram(gl, program, function() {
                linkSuccess = false;
            });
            return linkSuccess ? program : null;
        };


        var getActiveMap = function(gl, program, typeInfo) {
            var numVariables = gl.getProgramParameter(program, gl[typeInfo.param]);
            var variables = {};
            for (var ii = 0; ii < numVariables; ++ii) {
                var info = gl[typeInfo.activeFn](program, ii);
                variables[info.name] = {
                    name: info.name,
                    size: info.size,
                    type: info.type,
                    location: gl[typeInfo.locFn](program, info.name)
                };
            }
            return variables;
        };

        /**
         * Returns a map of attrib names to info about those
         * attribs
         *
         * eg:
         *    { "attrib1Name":
         *      {
         *        name: "attrib1Name",
         *        size: 1,
         *        type: gl.FLOAT_MAT2,
         *        location: 0
         *      },
         *      "attrib2Name[0]":
         *      {
         *         name: "attrib2Name[0]",
         *         size: 4,
         *         type: gl.FLOAT,
         *         location: 1
         *      },
         *    }
         *
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {WebGLProgram} The program to query for attribs.
         * @return the map.
         */
        var getAttribMap = function(gl, program) {
            return getActiveMap(gl, program, {
                param: "ACTIVE_ATTRIBS",
                activeFn: "getActiveAttrib",
                locFn: "getAttribLocation"
            });
        };

        /**
         * Returns a map of uniform names to info about those uniform
         *
         * eg:
         *    { "uniform1Name":
         *      {
         *        name: "uniform1Name",
         *        size: 1,
         *        type: gl.FLOAT_MAT2,
         *        location: WebGLUniformLocation
         *      },
         *      "uniform2Name[0]":
         *      {
         *         name: "uniform2Name[0]",
         *         size: 4,
         *         type: gl.FLOAT,
         *         location: WebGLUniformLocation
         *      },
         *    }
         *
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {WebGLProgram} The program to query for uniforms.
         * @return the map.
         */
        var getUniformMap = function(gl, program) {
            return getActiveMap(gl, program, {
                param: "ACTIVE_UNIFORMS",
                activeFn: "getActiveUniform",
                locFn: "getUniformLocation"
            });
        };

        var basePath;
        var getBasePath = function() {
            return ''
        };

        var loadStandardVertexShader = function(gl) {
            return loadShaderFromFile(
                gl, getBasePath() + "vertexShader.vert", gl.VERTEX_SHADER);
        };

        var loadStandardFragmentShader = function(gl) {
            return loadShaderFromFile(
                gl, getBasePath() + "fragmentShader.frag", gl.FRAGMENT_SHADER);
        };

        /**
         * Loads an image asynchronously.
         * @param {string} url URL of image to load.
         * @param {!function(!Element): void} callback Function to call
         *     with loaded image.
         */
        var loadImageAsync = function(url, callback) {
            throw new Error("Image not supported")
        };

        /**
         * Loads an array of images.
         * @param {!Array.<string>} urls URLs of images to load.
         * @param {!function(!{string, img}): void} callback. Callback
         *     that gets passed map of urls to img tags.
         */
        var loadImagesAsync = function(urls, callback) {
            throw new Error("loadImagesAsync not supported")
        };

        var getUrlArguments = function() {
            return {}
        };

        var makeImage = function(canvas) {
            var imgData = canvas.getContext("2d").getImageData(
                0, 0, canvas.width, canvas.height)
            var img = new Image()
            img._width = imgData.width
            img._height = imgData.height
            img._data = imgData.data
            return img
        };

        var insertImage = function(element, caption, img) {};

        var addShaderSource = function(element, label, source, opt_url) {};

        // Add your prefix here.
        var browserPrefixes = [
            "",
            "MOZ_",
            "OP_",
            "WEBKIT_"
        ];

        /**
         * Given an extension name like WEBGL_compressed_texture_s3tc
         * returns the name of the supported version extension, like
         * WEBKIT_WEBGL_compressed_teture_s3tc
         * @param {string} name Name of extension to look for
         * @return {string} name of extension found or undefined if not
         *     found.
         */
        var getSupportedExtensionWithKnownPrefixes = function(gl, name) {
            var supported = gl.getSupportedExtensions();
            for (var ii = 0; ii < browserPrefixes.length; ++ii) {
                var prefixedName = browserPrefixes[ii] + name;
                if (supported.indexOf(prefixedName) >= 0) {
                    return prefixedName;
                }
            }
        };

        /**
         * Given an extension name like WEBGL_compressed_texture_s3tc
         * returns the supported version extension, like
         * WEBKIT_WEBGL_compressed_teture_s3tc
         * @param {string} name Name of extension to look for
         * @return {WebGLExtension} The extension or undefined if not
         *     found.
         */
        var getExtensionWithKnownPrefixes = function(gl, name) {
            for (var ii = 0; ii < browserPrefixes.length; ++ii) {
                var prefixedName = browserPrefixes[ii] + name;
                var ext = gl.getExtension(prefixedName);
                if (ext) {
                    return ext;
                }
            }
        };


        var replaceRE = /\$\((\w+)\)/g;

        /**
         * Replaces strings with property values.
         * Given a string like "hello $(first) $(last)" and an object
         * like {first:"John", last:"Smith"} will return
         * "hello John Smith".
         * @param {string} str String to do replacements in
         * @param {...} 1 or more objects conaining properties.
         */
        var replaceParams = function(str) {
            var args = arguments;
            return str.replace(replaceRE, function(str, p1, offset, s) {
                for (var ii = 1; ii < args.length; ++ii) {
                    if (args[ii][p1] !== undefined) {
                        return args[ii][p1];
                    }
                }
                throw "unknown string param '" + p1 + "'";
            });
        };


        /**
         * Provides requestAnimationFrame in a cross browser way.
         */
        var requestAnimFrameImpl_;

        var requestAnimFrame = function(callback, element) {
            if (!requestAnimFrameImpl_) {
                requestAnimFrameImpl_ = function() {
                    return function(callback, element) {
                        return setTimeout(callback, 1000 / 70);
                    };
                }();
            }

            return requestAnimFrameImpl_(callback, element);
        };

        /**
         * Provides cancelAnimationFrame in a cross browser way.
         */
        var cancelAnimFrame = (function() {
            return clearTimeout;
        })();

        /**
         * Waits for the browser to composite the canvas associated with
         * the WebGL context passed in.
         */
        var waitForComposite = function(gl, callback) {
            if (typeof gl === 'function') {
                callback = gl;
            }
            var frames = 5;
            var countDown = function() {
                if (frames == 0) {
                    callback();
                } else {
                    --frames;
                    requestAnimFrame(countDown);
                }
            };
            countDown();
        };

        /**
         * Starts playing a video and waits for it to be consumable.
         * @param {!HTMLVideoElement} video An HTML5 Video element.
         * @param {!function(!HTMLVideoElement): void>} callback. Function to call when
         *        video is ready.
         */
        var startPlayingAndWaitForVideo = function(video, callback) {
            var gotPlaying = false;
            var gotTimeUpdate = false;

            var maybeCallCallback = function() {
                if (gotPlaying && gotTimeUpdate && callback) {
                    callback(video);
                    callback = undefined;
                    video.removeEventListener('playing', playingListener, true);
                    video.removeEventListener('timeupdate', timeupdateListener, true);
                }
            };

            var playingListener = function() {
                gotPlaying = true;
                maybeCallCallback();
            };

            var timeupdateListener = function() {
                // Checking to make sure the current time has advanced beyond
                // the start time seems to be a reliable heuristic that the
                // video element has data that can be consumed.
                if (video.currentTime > 0.0) {
                    gotTimeUpdate = true;
                    maybeCallCallback();
                }
            };

            video.addEventListener('playing', playingListener, true);
            video.addEventListener('timeupdate', timeupdateListener, true);
            video.loop = true;
            video.play();
        };

        /**
         * Runs an array of functions, yielding to the browser between each step.
         * If you want to know when all the steps are finished add a last step.
         * @param {!Array.<function(): void>} steps. Array of functions.
         */
        var runSteps = function(steps) {
            if (!steps.length) {
                return;
            }

            // copy steps so they can't be modifed.
            var stepsToRun = steps.slice();
            var currentStep = 0;
            var runNextStep = function() {
                stepsToRun[currentStep++]();
                if (currentStep < stepsToRun.length) {
                    setTimeout(runNextStep, 1);
                }
            };
            runNextStep();
        };


        /**
         * Given an extension name like WEBGL_compressed_texture_s3tc
         * returns the supported version extension, like
         * WEBKIT_WEBGL_compressed_teture_s3tc
         * @param {string} name Name of extension to look for.
         * @return {WebGLExtension} The extension or undefined if not
         *     found.
         */
        var getExtensionWithKnownPrefixes = function(gl, name) {
            for (var ii = 0; ii < browserPrefixes.length; ++ii) {
                var prefixedName = browserPrefixes[ii] + name;
                var ext = gl.getExtension(prefixedName);
                if (ext) {
                    return ext;
                }
            }
        };

        /**
         * Returns possible prefixed versions of an extension's name.
         * @param {string} name Name of extension. May already include a prefix.
         * @return {Array.<string>} Variations of the extension name with known
         *     browser prefixes.
         */
        var getExtensionPrefixedNames = function(name) {
            var unprefix = function(name) {
                for (var ii = 0; ii < browserPrefixes.length; ++ii) {
                    if (browserPrefixes[ii].length > 0 &&
                        name.substring(0, browserPrefixes[ii].length).toLowerCase() ===
                        browserPrefixes[ii].toLowerCase()) {
                        return name.substring(browserPrefixes[ii].length);
                    }
                }
                return name;
            }

            var unprefixed = unprefix(name);

            var variations = [];
            for (var ii = 0; ii < browserPrefixes.length; ++ii) {
                variations.push(browserPrefixes[ii] + unprefixed);
            }

            return variations;
        };

        return {
            addShaderSource: addShaderSource,
            cancelAnimFrame: cancelAnimFrame,
            create3DContext: create3DContext,
            create3DContextWithWrapperThatThrowsOnGLError: create3DContextWithWrapperThatThrowsOnGLError,
            checkCanvas: checkCanvas,
            checkCanvasRect: checkCanvasRect,
            checkCanvasRectColor: checkCanvasRectColor,
            checkAreaInAndOut: checkAreaInAndOut,
            createColoredTexture: createColoredTexture,
            createProgram: createProgram,
            clearAndDrawUnitQuad: clearAndDrawUnitQuad,
            clearAndDrawIndexedQuad: clearAndDrawIndexedQuad,
            drawUnitQuad: drawUnitQuad,
            drawIndexedQuad: drawIndexedQuad,
            drawUByteColorQuad: drawUByteColorQuad,
            drawFloatColorQuad: drawFloatColorQuad,
            endsWith: endsWith,
            fillTexture: fillTexture,
            getExtensionWithKnownPrefixes: getExtensionWithKnownPrefixes,
            getFileListAsync: getFileListAsync,
            getLastError: getLastError,
            getScript: getScript,
            getSupportedExtensionWithKnownPrefixes: getSupportedExtensionWithKnownPrefixes,
            getUrlArguments: getUrlArguments,
            getUrlOptions: getUrlOptions,
            getAttribMap: getAttribMap,
            getUniformMap: getUniformMap,
            glEnumToString: glEnumToString,
            glErrorShouldBe: glErrorShouldBe,
            hasAttributeCaseInsensitive: hasAttributeCaseInsensitive,
            insertImage: insertImage,
            loadImageAsync: loadImageAsync,
            loadImagesAsync: loadImagesAsync,
            loadProgram: loadProgram,
            loadProgramFromFile: loadProgramFromFile,
            loadProgramFromScript: loadProgramFromScript,
            loadProgramFromScriptExpectError: loadProgramFromScriptExpectError,
            loadShader: loadShader,
            loadShaderFromFile: loadShaderFromFile,
            loadShaderFromScript: loadShaderFromScript,
            loadStandardProgram: loadStandardProgram,
            loadStandardVertexShader: loadStandardVertexShader,
            loadStandardFragmentShader: loadStandardFragmentShader,
            loadTextFileAsync: loadTextFileAsync,
            loadTexture: loadTexture,
            log: log,
            loggingOff: loggingOff,
            makeImage: makeImage,
            error: error,
            shallowCopyObject: shallowCopyObject,
            setupColorQuad: setupColorQuad,
            setupProgram: setupProgram,
            setupIndexedQuad: setupIndexedQuad,
            setupIndexedQuadWithOptions: setupIndexedQuadWithOptions,
            setupSimpleColorFragmentShader: setupSimpleColorFragmentShader,
            setupSimpleColorVertexShader: setupSimpleColorVertexShader,
            setupSimpleColorProgram: setupSimpleColorProgram,
            setupSimpleTextureFragmentShader: setupSimpleTextureFragmentShader,
            setupSimpleTextureProgram: setupSimpleTextureProgram,
            setupSimpleTextureVertexShader: setupSimpleTextureVertexShader,
            setupSimpleVertexColorFragmentShader: setupSimpleVertexColorFragmentShader,
            setupSimpleVertexColorProgram: setupSimpleVertexColorProgram,
            setupSimpleVertexColorVertexShader: setupSimpleVertexColorVertexShader,
            setupNoTexCoordTextureProgram: setupNoTexCoordTextureProgram,
            setupNoTexCoordTextureVertexShader: setupNoTexCoordTextureVertexShader,
            setupTexturedQuad: setupTexturedQuad,
            setupTexturedQuadWithTexCoords: setupTexturedQuadWithTexCoords,
            setupUnitQuad: setupUnitQuad,
            setupUnitQuadWithTexCoords: setupUnitQuadWithTexCoords,
            setupQuad: setupQuad,
            setFloatDrawColor: setFloatDrawColor,
            setUByteDrawColor: setUByteDrawColor,
            startPlayingAndWaitForVideo: startPlayingAndWaitForVideo,
            startsWith: startsWith,
            shouldGenerateGLError: shouldGenerateGLError,
            readFile: readFile,
            readFileList: readFileList,
            replaceParams: replaceParams,
            requestAnimFrame: requestAnimFrame,
            waitForComposite: waitForComposite,
            runSteps: runSteps,
            getExtensionPrefixedNames: getExtensionPrefixedNames,

            none: false
        }
    }


    var WebGLTestUtils = createTestUtils();;;
    /*
     ** Copyright (c) 2012 The Khronos Group Inc.
     **
     ** Permission is hereby granted, free of charge, to any person obtaining a
     ** copy of this software and/or associated documentation files (the
     ** "Materials"), to deal in the Materials without restriction, including
     ** without limitation the rights to use, copy, modify, merge, publish,
     ** distribute, sublicense, and/or sell copies of the Materials, and to
     ** permit persons to whom the Materials are furnished to do so, subject to
     ** the following conditions:
     **
     ** The above copyright notice and this permission notice shall be included
     ** in all copies or substantial portions of the Materials.
     **
     ** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     ** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     ** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     ** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     ** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
     ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
     ** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
     */
    GLSLGenerator = (function() {

        var vertexShaderTemplate = [
            "attribute vec4 aPosition;",
            "",
            "varying vec4 vColor;",
            "",
            "$(extra)",
            "$(emu)",
            "",
            "void main()",
            "{",
            "   gl_Position = aPosition;",
            "   vec2 texcoord = vec2(aPosition.xy * 0.5 + vec2(0.5, 0.5));",
            "   vec4 color = vec4(",
            "       texcoord,",
            "       texcoord.x * texcoord.y,",
            "       (1.0 - texcoord.x) * texcoord.y * 0.5 + 0.5);",
            "   $(test)",
            "}"
        ].join("\n");

        var fragmentShaderTemplate = [
            "#if defined(GL_ES)",
            "precision mediump float;",
            "#endif",
            "",
            "varying vec4 vColor;",
            "",
            "$(extra)",
            "$(emu)",
            "",
            "void main()",
            "{",
            "   $(test)",
            "}"
        ].join("\n");

        var baseVertexShader = [
            "attribute vec4 aPosition;",
            "",
            "varying vec4 vColor;",
            "",
            "void main()",
            "{",
            "   gl_Position = aPosition;",
            "   vec2 texcoord = vec2(aPosition.xy * 0.5 + vec2(0.5, 0.5));",
            "   vColor = vec4(",
            "       texcoord,",
            "       texcoord.x * texcoord.y,",
            "       (1.0 - texcoord.x) * texcoord.y * 0.5 + 0.5);",
            "}"
        ].join("\n");

        var baseVertexShaderWithColor = [
            "attribute vec4 aPosition;",
            "attribute vec4 aColor;",
            "",
            "varying vec4 vColor;",
            "",
            "void main()",
            "{",
            "   gl_Position = aPosition;",
            "   vColor = aColor;",
            "}"
        ].join("\n");

        var baseFragmentShader = [
            "#if defined(GL_ES)",
            "precision mediump float;",
            "#endif",
            "varying vec4 vColor;",
            "",
            "void main()",
            "{",
            "   gl_FragColor = vColor;",
            "}"
        ].join("\n");

        var types = [{
            type: "float",
            code: [
                "float $(func)_emu($(args)) {",
                "  return $(func)_base($(baseArgs));",
                "}"
            ].join("\n")
        }, {
            type: "vec2",
            code: [
                "vec2 $(func)_emu($(args)) {",
                "  return vec2(",
                "      $(func)_base($(baseArgsX)),",
                "      $(func)_base($(baseArgsY)));",
                "}"
            ].join("\n")
        }, {
            type: "vec3",
            code: [
                "vec3 $(func)_emu($(args)) {",
                "  return vec3(",
                "      $(func)_base($(baseArgsX)),",
                "      $(func)_base($(baseArgsY)),",
                "      $(func)_base($(baseArgsZ)));",
                "}"
            ].join("\n")
        }, {
            type: "vec4",
            code: [
                "vec4 $(func)_emu($(args)) {",
                "  return vec4(",
                "      $(func)_base($(baseArgsX)),",
                "      $(func)_base($(baseArgsY)),",
                "      $(func)_base($(baseArgsZ)),",
                "      $(func)_base($(baseArgsW)));",
                "}"
            ].join("\n")
        }];

        var bvecTypes = [{
            type: "bvec2",
            code: [
                "bvec2 $(func)_emu($(args)) {",
                "  return bvec2(",
                "      $(func)_base($(baseArgsX)),",
                "      $(func)_base($(baseArgsY)));",
                "}"
            ].join("\n")
        }, {
            type: "bvec3",
            code: [
                "bvec3 $(func)_emu($(args)) {",
                "  return bvec3(",
                "      $(func)_base($(baseArgsX)),",
                "      $(func)_base($(baseArgsY)),",
                "      $(func)_base($(baseArgsZ)));",
                "}"
            ].join("\n")
        }, {
            type: "bvec4",
            code: [
                "vec4 $(func)_emu($(args)) {",
                "  return bvec4(",
                "      $(func)_base($(baseArgsX)),",
                "      $(func)_base($(baseArgsY)),",
                "      $(func)_base($(baseArgsZ)),",
                "      $(func)_base($(baseArgsW)));",
                "}"
            ].join("\n")
        }];

        var replaceRE = /\$\((\w+)\)/g;

        var replaceParams = function(str) {
            var args = arguments;
            return str.replace(replaceRE, function(str, p1, offset, s) {
                for (var ii = 1; ii < args.length; ++ii) {
                    if (args[ii][p1] !== undefined) {
                        return args[ii][p1];
                    }
                }
                throw "unknown string param '" + p1 + "'";
            });
        };

        var generateReferenceShader = function(
            shaderInfo, template, params, typeInfo, test) {
            var input = shaderInfo.input;
            var output = shaderInfo.output;
            var feature = params.feature;
            var testFunc = params.testFunc;
            var emuFunc = params.emuFunc || "";
            var extra = params.extra || '';
            var args = params.args || "$(type) value";
            var type = typeInfo.type;
            var typeCode = typeInfo.code;

            var baseArgs = params.baseArgs || "value$(field)";
            var baseArgsX = replaceParams(baseArgs, {
                field: ".x"
            });
            var baseArgsY = replaceParams(baseArgs, {
                field: ".y"
            });
            var baseArgsZ = replaceParams(baseArgs, {
                field: ".z"
            });
            var baseArgsW = replaceParams(baseArgs, {
                field: ".w"
            });
            var baseArgs = replaceParams(baseArgs, {
                field: ""
            });

            test = replaceParams(test, {
                input: input,
                output: output,
                func: feature + "_emu"
            });
            emuFunc = replaceParams(emuFunc, {
                func: feature
            });
            args = replaceParams(args, {
                type: type
            });
            typeCode = replaceParams(typeCode, {
                func: feature,
                type: type,
                args: args,
                baseArgs: baseArgs,
                baseArgsX: baseArgsX,
                baseArgsY: baseArgsY,
                baseArgsZ: baseArgsZ,
                baseArgsW: baseArgsW
            });
            var shader = replaceParams(template, {
                extra: extra,
                emu: emuFunc + "\n\n" + typeCode,
                test: test
            });
            return shader;
        };

        var generateTestShader = function(
            shaderInfo, template, params, test) {
            var input = shaderInfo.input;
            var output = shaderInfo.output;
            var feature = params.feature;
            var testFunc = params.testFunc;
            var extra = params.extra || '';

            test = replaceParams(test, {
                input: input,
                output: output,
                func: feature
            });
            var shader = replaceParams(template, {
                extra: extra,
                emu: '',
                test: test
            });
            return shader;
        };

        var runFeatureTest = function(params) {
            var wtu = WebGLTestUtils;
            var gridRes = params.gridRes;
            var vertexTolerance = params.tolerance || 0;
            var fragmentTolerance = vertexTolerance;
            if ('fragmentTolerance' in params)
                fragmentTolerance = params.fragmentTolerance || 0;

            description("Testing GLSL feature: " + params.feature);

            var width = 32;
            var height = 32;

            var console = document.getElementById("console");
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var gl = wtu.create3DContext(canvas, {
                premultipliedAlpha: false
            });
            if (!gl) {
                testFailed("context does not exist");
                finishTest();
                return;
            }

            var canvas2d = document.createElement('canvas');
            canvas2d.width = width;
            canvas2d.height = height;
            var ctx = canvas2d.getContext("2d");
            var imgData = ctx.getImageData(0, 0, width, height);

            var shaderInfos = [{
                type: "vertex",
                input: "color",
                output: "vColor",
                vertexShaderTemplate: vertexShaderTemplate,
                fragmentShaderTemplate: baseFragmentShader,
                tolerance: vertexTolerance
            }, {
                type: "fragment",
                input: "vColor",
                output: "gl_FragColor",
                vertexShaderTemplate: baseVertexShader,
                fragmentShaderTemplate: fragmentShaderTemplate,
                tolerance: fragmentTolerance
            }];
            for (var ss = 0; ss < shaderInfos.length; ++ss) {
                var shaderInfo = shaderInfos[ss];
                var tests = params.tests;
                var testTypes = params.emuFuncs || (params.bvecTest ? bvecTypes : types);
                // Test vertex shaders
                for (var ii = 0; ii < tests.length; ++ii) {
                    var type = testTypes[ii];
                    if (params.simpleEmu) {
                        type = {
                            type: type.type,
                            code: params.simpleEmu
                        };
                    }
                    debug("");
                    var str = replaceParams(params.testFunc, {
                        func: params.feature,
                        type: type.type,
                        arg0: type.type
                    });
                    debug("Testing: " + str + " in " + shaderInfo.type + " shader");

                    var referenceVertexShaderSource = generateReferenceShader(
                        shaderInfo,
                        shaderInfo.vertexShaderTemplate,
                        params,
                        type,
                        tests[ii]);
                    var referenceFragmentShaderSource = generateReferenceShader(
                        shaderInfo,
                        shaderInfo.fragmentShaderTemplate,
                        params,
                        type,
                        tests[ii]);
                    var testVertexShaderSource = generateTestShader(
                        shaderInfo,
                        shaderInfo.vertexShaderTemplate,
                        params,
                        tests[ii]);
                    var testFragmentShaderSource = generateTestShader(
                        shaderInfo,
                        shaderInfo.fragmentShaderTemplate,
                        params,
                        tests[ii]);

                    debug("");
                    wtu.addShaderSource(
                        console, "reference vertex shader", referenceVertexShaderSource);
                    wtu.addShaderSource(
                        console, "reference fragment shader", referenceFragmentShaderSource);
                    wtu.addShaderSource(
                        console, "test vertex shader", testVertexShaderSource);
                    wtu.addShaderSource(
                        console, "test fragment shader", testFragmentShaderSource);
                    debug("");

                    var refData = draw(
                        canvas, referenceVertexShaderSource, referenceFragmentShaderSource);
                    var refImg = wtu.makeImage(canvas);
                    if (ss == 0) {
                        var testData = draw(
                            canvas, testVertexShaderSource, referenceFragmentShaderSource);
                    } else {
                        var testData = draw(
                            canvas, referenceVertexShaderSource, testFragmentShaderSource);
                    }
                    var testImg = wtu.makeImage(canvas);

                    reportResults(refData, refImg, testData, testImg, shaderInfo.tolerance);
                }
            }

            finishTest();

            function reportResults(refData, refImage, testData, testImage, tolerance) {
                var same = true;
                for (var yy = 0; yy < height; ++yy) {
                    for (var xx = 0; xx < width; ++xx) {
                        var offset = (yy * width + xx) * 4;
                        var imgOffset = ((height - yy - 1) * width + xx) * 4;
                        imgData.data[imgOffset + 0] = 0;
                        imgData.data[imgOffset + 1] = 0;
                        imgData.data[imgOffset + 2] = 0;
                        imgData.data[imgOffset + 3] = 255;
                        if (Math.abs(refData[offset + 0] - testData[offset + 0]) > tolerance ||
                            Math.abs(refData[offset + 1] - testData[offset + 1]) > tolerance ||
                            Math.abs(refData[offset + 2] - testData[offset + 2]) > tolerance ||
                            Math.abs(refData[offset + 3] - testData[offset + 3]) > tolerance) {
                            imgData.data[imgOffset] = 255;
                            same = false;
                        }
                    }
                }

                var diffImg = null;
                if (!same) {
                    ctx.putImageData(imgData, 0, 0);
                    diffImg = wtu.makeImage(canvas2d);
                }

                /*
                var div = document.createElement("div");
                div.className = "testimages";
                wtu.insertImage(div, "ref", refImg);
                wtu.insertImage(div, "test", testImg);
                if (diffImg) {
                  wtu.insertImage(div, "diff", diffImg);
                }
                div.appendChild(document.createElement('br'));


                console.appendChild(div);
                */

                if (!same) {
                    testFailed("images are different");
                } else {
                    testPassed("images are the same");
                }

                //console.appendChild(document.createElement('hr'));
            }

            function draw(canvas, vsSource, fsSource) {
                var program = wtu.loadProgram(gl, vsSource, fsSource, testFailed);

                var posLoc = gl.getAttribLocation(program, "aPosition");
                wtu.setupIndexedQuad(gl, gridRes, posLoc);

                gl.useProgram(program);
                wtu.clearAndDrawIndexedQuad(gl, gridRes, [0, 0, 255, 255]);
                wtu.glErrorShouldBe(gl, gl.NO_ERROR, "no errors from draw");

                var img = new Uint8Array(width * height * 4);
                gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, img);
                return img;
            }

        };

        var runBasicTest = function(params) {
            var wtu = WebGLTestUtils;
            var gridRes = params.gridRes;
            var vertexTolerance = params.tolerance || 0;
            var fragmentTolerance = vertexTolerance;
            if ('fragmentTolerance' in params)
                fragmentTolerance = params.fragmentTolerance || 0;

            description("Testing : " + document.getElementsByTagName("title")[0].innerText);

            var width = 32;
            var height = 32;

            var console = document.getElementById("console");
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var gl = wtu.create3DContext(canvas);
            if (!gl) {
                testFailed("context does not exist");
                finishTest();
                return;
            }

            var canvas2d = document.createElement('canvas');
            canvas2d.width = width;
            canvas2d.height = height;
            var ctx = canvas2d.getContext("2d");
            var imgData = ctx.getImageData(0, 0, width, height);

            var shaderInfos = [{
                type: "vertex",
                input: "color",
                output: "vColor",
                vertexShaderTemplate: vertexShaderTemplate,
                fragmentShaderTemplate: baseFragmentShader,
                tolerance: vertexTolerance
            }, {
                type: "fragment",
                input: "vColor",
                output: "gl_FragColor",
                vertexShaderTemplate: baseVertexShader,
                fragmentShaderTemplate: fragmentShaderTemplate,
                tolerance: fragmentTolerance
            }];
            for (var ss = 0; ss < shaderInfos.length; ++ss) {
                var shaderInfo = shaderInfos[ss];
                var tests = params.tests;
                //    var testTypes = params.emuFuncs || (params.bvecTest ? bvecTypes : types);
                // Test vertex shaders
                for (var ii = 0; ii < tests.length; ++ii) {
                    var test = tests[ii];
                    debug("");
                    debug("Testing: " + test.name + " in " + shaderInfo.type + " shader");

                    function genShader(shaderInfo, template, shader, subs) {
                        shader = replaceParams(shader, subs, {
                            input: shaderInfo.input,
                            output: shaderInfo.output
                        });
                        shader = replaceParams(template, subs, {
                            test: shader,
                            emu: "",
                            extra: ""
                        });
                        return shader;
                    }

                    var referenceVertexShaderSource = genShader(
                        shaderInfo,
                        shaderInfo.vertexShaderTemplate,
                        test.reference.shader,
                        test.reference.subs);
                    var referenceFragmentShaderSource = genShader(
                        shaderInfo,
                        shaderInfo.fragmentShaderTemplate,
                        test.reference.shader,
                        test.reference.subs);
                    var testVertexShaderSource = genShader(
                        shaderInfo,
                        shaderInfo.vertexShaderTemplate,
                        test.test.shader,
                        test.test.subs);
                    var testFragmentShaderSource = genShader(
                        shaderInfo,
                        shaderInfo.fragmentShaderTemplate,
                        test.test.shader,
                        test.test.subs);

                    debug("");
                    wtu.addShaderSource(
                        console, "reference vertex shader", referenceVertexShaderSource);
                    wtu.addShaderSource(
                        console, "reference fragment shader", referenceFragmentShaderSource);
                    wtu.addShaderSource(
                        console, "test vertex shader", testVertexShaderSource);
                    wtu.addShaderSource(
                        console, "test fragment shader", testFragmentShaderSource);
                    debug("");

                    var refData = draw(
                        canvas, referenceVertexShaderSource, referenceFragmentShaderSource);
                    var refImg = wtu.makeImage(canvas);
                    if (ss == 0) {
                        var testData = draw(
                            canvas, testVertexShaderSource, referenceFragmentShaderSource);
                    } else {
                        var testData = draw(
                            canvas, referenceVertexShaderSource, testFragmentShaderSource);
                    }
                    var testImg = wtu.makeImage(canvas);

                    reportResults(refData, refImg, testData, testImg, shaderInfo.tolerance);
                }
            }

            finishTest();

            function reportResults(refData, refImage, testData, testImage, tolerance) {
                var same = true;
                for (var yy = 0; yy < height; ++yy) {
                    for (var xx = 0; xx < width; ++xx) {
                        var offset = (yy * width + xx) * 4;
                        var imgOffset = ((height - yy - 1) * width + xx) * 4;
                        imgData.data[imgOffset + 0] = 0;
                        imgData.data[imgOffset + 1] = 0;
                        imgData.data[imgOffset + 2] = 0;
                        imgData.data[imgOffset + 3] = 255;
                        if (Math.abs(refData[offset + 0] - testData[offset + 0]) > tolerance ||
                            Math.abs(refData[offset + 1] - testData[offset + 1]) > tolerance ||
                            Math.abs(refData[offset + 2] - testData[offset + 2]) > tolerance ||
                            Math.abs(refData[offset + 3] - testData[offset + 3]) > tolerance) {
                            imgData.data[imgOffset] = 255;
                            same = false;
                        }
                    }
                }

                var diffImg = null;
                if (!same) {
                    ctx.putImageData(imgData, 0, 0);
                    diffImg = wtu.makeImage(canvas2d);
                }

                /*
                var div = document.createElement("div");
                div.className = "testimages";
                wtu.insertImage(div, "ref", refImg);
                wtu.insertImage(div, "test", testImg);
                if (diffImg) {
                  wtu.insertImage(div, "diff", diffImg);
                }
                div.appendChild(document.createElement('br'));

                console.appendChild(div);
                */

                if (!same) {
                    testFailed("images are different");
                } else {
                    testPassed("images are the same");
                }

                //console.appendChild(document.createElement('hr'));
            }

            function draw(canvas, vsSource, fsSource) {
                var program = wtu.loadProgram(gl, vsSource, fsSource, testFailed);

                var posLoc = gl.getAttribLocation(program, "aPosition");
                wtu.setupIndexedQuad(gl, gridRes, posLoc);

                gl.useProgram(program);
                wtu.clearAndDrawIndexedQuad(gl, gridRes, [0, 0, 255, 255]);
                wtu.glErrorShouldBe(gl, gl.NO_ERROR, "no errors from draw");

                var img = new Uint8Array(width * height * 4);
                gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, img);
                return img;
            }

        };

        var runReferenceImageTest = function(params) {
            var wtu = WebGLTestUtils;
            var gridRes = params.gridRes;
            var vertexTolerance = params.tolerance || 0;
            var fragmentTolerance = vertexTolerance;
            if ('fragmentTolerance' in params)
                fragmentTolerance = params.fragmentTolerance || 0;

            description("Testing GLSL feature: " + params.feature);

            var width = 32;
            var height = 32;

            var console = document.getElementById("console");
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var gl = wtu.create3DContext(canvas, {
                antialias: false,
                premultipliedAlpha: false
            });
            if (!gl) {
                testFailed("context does not exist");
                finishTest();
                return;
            }

            var canvas2d = document.createElement('canvas');
            canvas2d.width = width;
            canvas2d.height = height;
            var ctx = canvas2d.getContext("2d");
            var imgData = ctx.getImageData(0, 0, width, height);

            // State for reference images for vertex shader tests.
            // These are drawn with the same tessellated grid as the test vertex
            // shader so that the interpolation is identical. The grid is reused
            // from test to test; the colors are changed.

            var indexedQuadForReferenceVertexShader =
                wtu.setupIndexedQuad(gl, gridRes, 0);
            var referenceVertexShaderProgram =
                wtu.setupProgram(gl, [baseVertexShaderWithColor, baseFragmentShader], ["aPosition", "aColor"]);
            var referenceVertexShaderColorBuffer = gl.createBuffer();

            var shaderInfos = [{
                type: "vertex",
                input: "color",
                output: "vColor",
                vertexShaderTemplate: vertexShaderTemplate,
                fragmentShaderTemplate: baseFragmentShader,
                tolerance: vertexTolerance
            }, {
                type: "fragment",
                input: "vColor",
                output: "gl_FragColor",
                vertexShaderTemplate: baseVertexShader,
                fragmentShaderTemplate: fragmentShaderTemplate,
                tolerance: fragmentTolerance
            }];
            for (var ss = 0; ss < shaderInfos.length; ++ss) {
                var shaderInfo = shaderInfos[ss];
                var tests = params.tests;
                var testTypes = params.emuFuncs || (params.bvecTest ? bvecTypes : types);
                // Test vertex shaders
                for (var ii = 0; ii < tests.length; ++ii) {
                    var type = testTypes[ii];
                    var isVertex = (ss == 0);
                    debug("");
                    var str = replaceParams(params.testFunc, {
                        func: params.feature,
                        type: type.type,
                        arg0: type.type
                    });
                    debug("Testing: " + str + " in " + shaderInfo.type + " shader");

                    var referenceVertexShaderSource = generateReferenceShader(
                        shaderInfo,
                        shaderInfo.vertexShaderTemplate,
                        params,
                        type,
                        tests[ii].source);
                    var referenceFragmentShaderSource = generateReferenceShader(
                        shaderInfo,
                        shaderInfo.fragmentShaderTemplate,
                        params,
                        type,
                        tests[ii].source);
                    var testVertexShaderSource = generateTestShader(
                        shaderInfo,
                        shaderInfo.vertexShaderTemplate,
                        params,
                        tests[ii].source);
                    var testFragmentShaderSource = generateTestShader(
                        shaderInfo,
                        shaderInfo.fragmentShaderTemplate,
                        params,
                        tests[ii].source);
                    var referenceTextureOrArray = generateReferenceImage(
                        gl,
                        tests[ii].generator,
                        isVertex ? gridRes : width,
                        isVertex ? gridRes : height,
                        isVertex);

                    debug("");
                    wtu.addShaderSource(
                        console, "test vertex shader", testVertexShaderSource);
                    wtu.addShaderSource(
                        console, "test fragment shader", testFragmentShaderSource);
                    debug("");
                    var refData;
                    if (isVertex) {
                        refData = drawVertexReferenceImage(canvas, referenceTextureOrArray);
                    } else {
                        refData = drawFragmentReferenceImage(canvas, referenceTextureOrArray);
                    }
                    var refImg = wtu.makeImage(canvas);
                    var testData;
                    if (isVertex) {
                        testData = draw(
                            canvas, testVertexShaderSource, referenceFragmentShaderSource);
                    } else {
                        testData = draw(
                            canvas, referenceVertexShaderSource, testFragmentShaderSource);
                    }
                    var testImg = wtu.makeImage(canvas);
                    var testTolerance = shaderInfo.tolerance;
                    // Provide per-test tolerance so that we can increase it only for those desired.
                    if ('tolerance' in tests[ii])
                        testTolerance = tests[ii].tolerance || 0;
                    reportResults(refData, refImg, testData, testImg, testTolerance);
                }
            }

            finishTest();

            function reportResults(refData, refImage, testData, testImage, tolerance) {
                var same = true;
                for (var yy = 0; yy < height; ++yy) {
                    for (var xx = 0; xx < width; ++xx) {
                        var offset = (yy * width + xx) * 4;
                        var imgOffset = ((height - yy - 1) * width + xx) * 4;
                        imgData.data[imgOffset + 0] = 0;
                        imgData.data[imgOffset + 1] = 0;
                        imgData.data[imgOffset + 2] = 0;
                        imgData.data[imgOffset + 3] = 255;
                        if (Math.abs(refData[offset + 0] - testData[offset + 0]) > tolerance ||
                            Math.abs(refData[offset + 1] - testData[offset + 1]) > tolerance ||
                            Math.abs(refData[offset + 2] - testData[offset + 2]) > tolerance ||
                            Math.abs(refData[offset + 3] - testData[offset + 3]) > tolerance) {
                            /*
                            console.appendChild(document.createTextNode('at (' + xx + ',' + yy + '): ref=(' +
                                                                        refData[offset + 0] + ',' +
                                                                        refData[offset + 1] + ',' +
                                                                        refData[offset + 2] + ',' +
                                                                        refData[offset + 3] + ')  test=(' +
                                                                        testData[offset + 0] + ',' +
                                                                        testData[offset + 1] + ',' +
                                                                        testData[offset + 2] + ',' +
                                                                        testData[offset + 3] + ')'));
                            console.appendChild(document.createElement('br'));

                            */

                            imgData.data[imgOffset] = 255;
                            same = false;
                        }
                    }
                }

                var diffImg = null;
                if (!same) {
                    ctx.putImageData(imgData, 0, 0);
                    diffImg = wtu.makeImage(canvas2d);
                }

                /*
                var div = document.createElement("div");
                div.className = "testimages";
                wtu.insertImage(div, "ref", refImg);
                wtu.insertImage(div, "test", testImg);
                if (diffImg) {
                  wtu.insertImage(div, "diff", diffImg);
                }
                div.appendChild(document.createElement('br'));

                console.appendChild(div);
                */

                if (!same) {
                    testFailed("images are different");
                } else {
                    testPassed("images are the same");
                }

                //console.appendChild(document.createElement('hr'));
            }

            function draw(canvas, vsSource, fsSource) {
                var program = wtu.loadProgram(gl, vsSource, fsSource, testFailed);

                var posLoc = gl.getAttribLocation(program, "aPosition");
                wtu.setupIndexedQuad(gl, gridRes, posLoc);

                gl.useProgram(program);
                wtu.clearAndDrawIndexedQuad(gl, gridRes, [0, 0, 255, 255]);
                wtu.glErrorShouldBe(gl, gl.NO_ERROR, "no errors from draw");

                var img = new Uint8Array(width * height * 4);
                gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, img);
                return img;
            }

            function drawVertexReferenceImage(canvas, colors) {
                gl.bindBuffer(gl.ARRAY_BUFFER, indexedQuadForReferenceVertexShader[0]);
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, referenceVertexShaderColorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(1);
                gl.vertexAttribPointer(1, 4, gl.UNSIGNED_BYTE, true, 0, 0);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexedQuadForReferenceVertexShader[1]);
                gl.useProgram(referenceVertexShaderProgram);
                wtu.clearAndDrawIndexedQuad(gl, gridRes);
                gl.disableVertexAttribArray(0);
                gl.disableVertexAttribArray(1);
                wtu.glErrorShouldBe(gl, gl.NO_ERROR, "no errors from draw");

                var img = new Uint8Array(width * height * 4);
                gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, img);
                return img;
            }

            function drawFragmentReferenceImage(canvas, texture) {
                var program = wtu.setupTexturedQuad(gl);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                var texLoc = gl.getUniformLocation(program, "tex");
                gl.uniform1i(texLoc, 0);
                wtu.clearAndDrawUnitQuad(gl);
                wtu.glErrorShouldBe(gl, gl.NO_ERROR, "no errors from draw");

                var img = new Uint8Array(width * height * 4);
                gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, img);
                return img;
            }

            /**
             * Creates and returns either a Uint8Array (for vertex shaders) or
             * WebGLTexture (for fragment shaders) containing the reference
             * image for the function being tested. Exactly how the function is
             * evaluated, and the size of the returned texture or array, depends on
             * whether we are testing a vertex or fragment shader. If a fragment
             * shader, the function is evaluated at the pixel centers. If a
             * vertex shader, the function is evaluated at the triangle's
             * vertices.
             *
             * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use to generate texture objects.
             * @param {!function(number,number,number,number): !Array.<number>} generator The reference image generator function.
             * @param {number} width The width of the texture to generate if testing a fragment shader; the grid resolution if testing a vertex shader.
             * @param {number} height The height of the texture to generate if testing a fragment shader; the grid resolution if testing a vertex shader.
             * @param {boolean} isVertex True if generating a reference image for a vertex shader; false if for a fragment shader.
             * @return {!WebGLTexture|!Uint8Array} The texture object or array that was generated.
             */
            function generateReferenceImage(
                gl,
                generator,
                width,
                height,
                isVertex) {

                // Note: the math in this function must match that in the vertex and
                // fragment shader templates above.
                function computeTexCoord(x) {
                    return x * 0.5 + 0.5;
                }

                function computeVertexColor(texCoordX, texCoordY) {
                    return [texCoordX,
                        texCoordY,
                        texCoordX * texCoordY,
                        (1.0 - texCoordX) * texCoordY * 0.5 + 0.5
                    ];
                }

                /**
                 * Computes fragment color according to the algorithm used for interpolation
                 * in OpenGL (GLES 2.0 spec 3.5.1, OpenGL 4.3 spec 14.6.1).
                 */
                function computeInterpolatedColor(texCoordX, texCoordY) {
                    // Calculate grid line indexes below and to the left from texCoord.
                    var gridBottom = Math.floor(texCoordY * gridRes);
                    if (gridBottom == gridRes) {
                        --gridBottom;
                    }
                    var gridLeft = Math.floor(texCoordX * gridRes);
                    if (gridLeft == gridRes) {
                        --gridLeft;
                    }

                    // Calculate coordinates relative to the grid cell.
                    var cellX = texCoordX * gridRes - gridLeft;
                    var cellY = texCoordY * gridRes - gridBottom;

                    // Barycentric coordinates inside either triangle ACD or ABC
                    // are used as weights for the vertex colors in the corners:
                    // A--B
                    // |\ |
                    // | \|
                    // D--C

                    var aColor = computeVertexColor(gridLeft / gridRes, (gridBottom + 1) / gridRes);
                    var bColor = computeVertexColor((gridLeft + 1) / gridRes, (gridBottom + 1) / gridRes);
                    var cColor = computeVertexColor((gridLeft + 1) / gridRes, gridBottom / gridRes);
                    var dColor = computeVertexColor(gridLeft / gridRes, gridBottom / gridRes);

                    // Calculate weights.
                    var a, b, c, d;

                    if (cellX + cellY < 1) {
                        // In bottom triangle ACD.
                        a = cellY; // area of triangle C-D-(cellX, cellY) relative to ACD
                        c = cellX; // area of triangle D-A-(cellX, cellY) relative to ACD
                        d = 1 - a - c;
                        b = 0;
                    } else {
                        // In top triangle ABC.
                        a = 1 - cellX; // area of the triangle B-C-(cellX, cellY) relative to ABC
                        c = 1 - cellY; // area of the triangle A-B-(cellX, cellY) relative to ABC
                        b = 1 - a - c;
                        d = 0;
                    }

                    var interpolated = [];
                    for (var ii = 0; ii < aColor.length; ++ii) {
                        interpolated.push(a * aColor[ii] + b * bColor[ii] + c * cColor[ii] + d * dColor[ii]);
                    }
                    return interpolated;
                }

                function clamp(value, minVal, maxVal) {
                    return Math.max(minVal, Math.min(value, maxVal));
                }

                // Evaluates the function at clip coordinates (px,py), storing the
                // result in the array "pixel". Each channel's result is clamped
                // between 0 and 255.
                function evaluateAtClipCoords(px, py, pixel, colorFunc) {
                    var tcx = computeTexCoord(px);
                    var tcy = computeTexCoord(py);

                    var color = colorFunc(tcx, tcy);

                    var output = generator(color[0], color[1], color[2], color[3]);

                    // Multiply by 256 to get even distribution for all values between 0 and 1.
                    // Use rounding rather than truncation to more closely match the GPU's behavior.
                    pixel[0] = clamp(Math.round(256 * output[0]), 0, 255);
                    pixel[1] = clamp(Math.round(256 * output[1]), 0, 255);
                    pixel[2] = clamp(Math.round(256 * output[2]), 0, 255);
                    pixel[3] = clamp(Math.round(256 * output[3]), 0, 255);
                }

                function generateFragmentReference() {
                    var data = new Uint8Array(4 * width * height);

                    var horizTexel = 1.0 / width;
                    var vertTexel = 1.0 / height;
                    var halfHorizTexel = 0.5 * horizTexel;
                    var halfVertTexel = 0.5 * vertTexel;

                    var pixel = new Array(4);

                    for (var yi = 0; yi < height; ++yi) {
                        for (var xi = 0; xi < width; ++xi) {
                            // The function must be evaluated at pixel centers.

                            // Compute desired position in clip space
                            var px = -1.0 + 2.0 * (halfHorizTexel + xi * horizTexel);
                            var py = -1.0 + 2.0 * (halfVertTexel + yi * vertTexel);

                            evaluateAtClipCoords(px, py, pixel, computeInterpolatedColor);
                            var index = 4 * (width * yi + xi);
                            data[index + 0] = pixel[0];
                            data[index + 1] = pixel[1];
                            data[index + 2] = pixel[2];
                            data[index + 3] = pixel[3];
                        }
                    }

                    var texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0,
                        gl.RGBA, gl.UNSIGNED_BYTE, data);
                    return texture;
                }

                function generateVertexReference() {
                    // We generate a Uint8Array which contains the evaluation of the
                    // function at the vertices of the triangle mesh. It is expected
                    // that the width and the height are identical, and equivalent
                    // to the grid resolution.
                    if (width != height) {
                        throw "width and height must be equal";
                    }

                    var texSize = 1 + width;
                    var data = new Uint8Array(4 * texSize * texSize);

                    var step = 2.0 / width;

                    var pixel = new Array(4);

                    for (var yi = 0; yi < texSize; ++yi) {
                        for (var xi = 0; xi < texSize; ++xi) {
                            // The function is evaluated at the triangles' vertices.

                            // Compute desired position in clip space
                            var px = -1.0 + (xi * step);
                            var py = -1.0 + (yi * step);

                            evaluateAtClipCoords(px, py, pixel, computeVertexColor);
                            var index = 4 * (texSize * yi + xi);
                            data[index + 0] = pixel[0];
                            data[index + 1] = pixel[1];
                            data[index + 2] = pixel[2];
                            data[index + 3] = pixel[3];
                        }
                    }

                    return data;
                }

                //----------------------------------------------------------------------
                // Body of generateReferenceImage
                //

                if (isVertex) {
                    return generateVertexReference();
                } else {
                    return generateFragmentReference();
                }
            }
        };

        return {
            /**
             * runs a bunch of GLSL tests using the passed in parameters
             * The parameters are:
             *
             * feature:
             *    the name of the function being tested (eg, sin, dot,
             *    normalize)
             *
             * testFunc:
             *    The prototype of function to be tested not including the
             *    return type.
             *
             * emuFunc:
             *    A base function that can be used to generate emulation
             *    functions. Example for 'ceil'
             *
             *      float $(func)_base(float value) {
             *        float m = mod(value, 1.0);
             *        return m != 0.0 ? (value + 1.0 - m) : value;
             *      }
             *
             * args:
             *    The arguments to the function
             *
             * baseArgs: (optional)
             *    The arguments when a base function is used to create an
             *    emulation function. For example 'float sign_base(float v)'
             *    is used to implemenent vec2 sign_emu(vec2 v).
             *
             * simpleEmu:
             *    if supplied, the code that can be used to generate all
             *    functions for all types.
             *
             *    Example for 'normalize':
             *
             *        $(type) $(func)_emu($(args)) {
             *           return value / length(value);
             *        }
             *
             * gridRes: (optional)
             *    The resolution of the mesh to generate. The default is a
             *    1x1 grid but many vertex shaders need a higher resolution
             *    otherwise the only values passed in are the 4 corners
             *    which often have the same value.
             *
             * tests:
             *    The code for each test. It is assumed the tests are for
             *    float, vec2, vec3, vec4 in that order.
             *
             * tolerance: (optional)
             *    Allow some tolerance in the comparisons. The tolerance is applied to
             *    both vertex and fragment shaders. The default tolerance is 0, meaning
             *    the values have to be identical.
             *
             * fragmentTolerance: (optional)
             *    Specify a tolerance which only applies to fragment shaders. The
             *    fragment-only tolerance will override the shared tolerance for
             *    fragment shaders if both are specified. Fragment shaders usually
             *    use mediump float precision so they sometimes require higher tolerance
             *    than vertex shaders which use highp by default.
             */
            runFeatureTest: runFeatureTest,

            /*
             * Runs a bunch of GLSL tests using the passed in parameters
             *
             * The parameters are:
             *
             * tests:
             *    Array of tests. For each test the following parameters are expected
             *
             *    name:
             *       some description of the test
             *    reference:
             *       parameters for the reference shader (see below)
             *    test:
             *       parameters for the test shader (see below)
             *
             *    The parameter for the reference and test shaders are
             *
             *    shader: the GLSL for the shader
             *    subs: any substitutions you wish to define for the shader.
             *
             *    Each shader is created from a basic template that
             *    defines an input and an output. You can see the
             *    templates at the top of this file. The input and output
             *    change depending on whether or not we are generating
             *    a vertex or fragment shader.
             *
             *    All this code function does is a bunch of string substitutions.
             *    A substitution is defined by $(name). If name is found in
             *    the 'subs' parameter it is replaced. 4 special names exist.
             *
             *    'input' the input to your GLSL. Always a vec4. All change
             *    from 0 to 1 over the quad to be drawn.
             *
             *    'output' the output color. Also a vec4
             *
             *    'emu' a place to insert extra stuff
             *    'extra' a place to insert extra stuff.
             *
             *    You can think of the templates like this
             *
             *       $(extra)
             *       $(emu)
             *
             *       void main() {
             *          // do math to calculate input
             *          ...
             *
             *          $(shader)
             *       }
             *
             *    Your shader first has any subs you provided applied as well
             *    as 'input' and 'output'
             *
             *    It is then inserted into the template which is also provided
             *    with your subs.
             *
             * gridRes: (optional)
             *    The resolution of the mesh to generate. The default is a
             *    1x1 grid but many vertex shaders need a higher resolution
             *    otherwise the only values passed in are the 4 corners
             *    which often have the same value.
             *
             * tolerance: (optional)
             *    Allow some tolerance in the comparisons. The tolerance is applied to
             *    both vertex and fragment shaders. The default tolerance is 0, meaning
             *    the values have to be identical.
             *
             * fragmentTolerance: (optional)
             *    Specify a tolerance which only applies to fragment shaders. The
             *    fragment-only tolerance will override the shared tolerance for
             *    fragment shaders if both are specified. Fragment shaders usually
             *    use mediump float precision so they sometimes require higher tolerance
             *    than vertex shaders which use highp.
             */
            runBasicTest: runBasicTest,

            /**
             * Runs a bunch of GLSL tests using the passed in parameters. The
             * expected results are computed as a reference image in JavaScript
             * instead of on the GPU. The parameters are:
             *
             * feature:
             *    the name of the function being tested (eg, sin, dot,
             *    normalize)
             *
             * testFunc:
             *    The prototype of function to be tested not including the
             *    return type.
             *
             * args:
             *    The arguments to the function
             *
             * gridRes: (optional)
             *    The resolution of the mesh to generate. The default is a
             *    1x1 grid but many vertex shaders need a higher resolution
             *    otherwise the only values passed in are the 4 corners
             *    which often have the same value.
             *
             * tests:
             *    Array of tests. It is assumed the tests are for float, vec2,
             *    vec3, vec4 in that order. For each test the following
             *    parameters are expected:
             *
             *       source: the GLSL source code for the tests
             *
             *       generator: a JavaScript function taking four parameters
             *       which evaluates the same function as the GLSL source,
             *       returning its result as a newly allocated array.
             *
             *       tolerance: (optional) a per-test tolerance.
             *
             * extra: (optional)
             *    Extra GLSL code inserted at the top of each test's shader.
             *
             * tolerance: (optional)
             *    Allow some tolerance in the comparisons. The tolerance is applied to
             *    both vertex and fragment shaders. The default tolerance is 0, meaning
             *    the values have to be identical.
             *
             * fragmentTolerance: (optional)
             *    Specify a tolerance which only applies to fragment shaders. The
             *    fragment-only tolerance will override the shared tolerance for
             *    fragment shaders if both are specified. Fragment shaders usually
             *    use mediump float precision so they sometimes require higher tolerance
             *    than vertex shaders which use highp.
             */
            runReferenceImageTest: runReferenceImageTest,

            none: false
        };

    }());;


    /******************* BEGIN TEST CASE *******************/




    "use strict";
    GLSLGenerator.runFeatureTest({
        feature: "mod",
        args: "$(type) value, $(type) divisor",
        baseArgs: "value$(field), divisor$(field)",
        testFunc: "$(func)($(type), $(type))",
        emuFunc: ["float $(func)_base(float value, float divisor) {",
            "  return value - divisor * floor(value / divisor);",
            "}"
        ].join("\n"),
        gridRes: 8,
        tolerance: 1,
        tests: [
            ["$(output) = vec4(",
                "    $(func)($(input).x * 6.0 - 3.0, 1.5) / 1.5,",
                "    $(func)($(input).y * 10.0 - 5.0, 2.1) / 2.1,",
                "    0,",
                "    1);"
            ].join("\n"), ["$(output) = vec4(",
                "    $(func)($(input).xy * vec2(6, 10) - vec2(3, 5), ",
                "       vec2(1.5, 2.1)) / vec2(1.5, 2.1),",
                "    0, 1);"
            ].join("\n"), ["$(output) = vec4(",
                "    $(func)($(input).xyz * vec3(6, 10, 8) - vec3(3, 5, 4), ",
                "       vec3(1.5, 2.1, 3.2)) / vec3(1.5, 2.1, 3.2),",
                "    1);"
            ].join("\n"), ["$(output) = ",
                "    $(func)($(input) * vec4(6, 10, 8, 4) - vec4(3, 5, 4, 2),",
                "       vec4(1.5, 2.1, 3.2, 1.1)) / vec4(1.5, 2.1, 3.2, 1.1);"
            ].join("\n")
        ]
    });
    var successfullyParsed = true;;


    /******************* END TEST CASE *******************/



    if (ENVIRONMENT.postHook) {
        ENVIRONMENT.postHook();
    }
};
module.exports = glsl_functions_glsl_function_mod_gentype