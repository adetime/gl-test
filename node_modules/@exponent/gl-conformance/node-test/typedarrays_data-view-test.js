/*eslint-disable */
var _windowShim = require("../lib/shims/window-shim");
var _documentShim = require("../lib/shims/document-shim");
var _canvasShim = require("../lib/shims/canvas-shim");
var _imageShim = require("../lib/shims/image-shim");
var _rafShim = require("../lib/shims/raf-shim");
var _RESOURCES = require("./resources.json");

function typedarrays_data_view_test(ENVIRONMENT) {
    var HTMLElement = function() {};
    ENVIRONMENT.CONTEXT_LIST = [];
    ENVIRONMENT.tape.end = (function(tape_end) {
        return function() {
            _rafShim.clear();
            ENVIRONMENT.CONTEXT_LIST.forEach(function(gl) {
                (gl.destroy && gl.destroy());
            });
            ENVIRONMENT.CONTEXT_LIST = [];
            tape_end.call(ENVIRONMENT.tape);
        }
    })(ENVIRONMENT.tape.end);
    ENVIRONMENT._createContext = ENVIRONMENT.createContext;
    ENVIRONMENT.createContext = function(w, h, o) {
        var gl = ENVIRONMENT._createContext(w, h, o);
        ENVIRONMENT.CONTEXT_LIST.push(gl);
        return gl;
    };
    ENVIRONMENT.document = _documentShim(ENVIRONMENT);
    ENVIRONMENT.window = _windowShim(ENVIRONMENT);
    ENVIRONMENT.scriptList = {};
    ENVIRONMENT.canvasList = [].map(function(opts) {
        return _canvasShim(ENVIRONMENT, opts);
    });
    ENVIRONMENT.RESOURCES = _RESOURCES;
    ENVIRONMENT.BASEPATH = "typedarrays";
    var document = ENVIRONMENT.document;
    var window = ENVIRONMENT.window;
    var Image = _imageShim;
    var requestAnimationFrame = _rafShim.requestAnimationFrame;
    var cancelAnimationFrame = _rafShim.cancelAnimationFrame;;
    /*
     ** Copyright (c) 2012 The Khronos Group Inc.
     **
     ** Permission is hereby granted, free of charge, to any person obtaining a
     ** copy of this software and/or associated documentation files (the
     ** "Materials"), to deal in the Materials without restriction, including
     ** without limitation the rights to use, copy, modify, merge, publish,
     ** distribute, sublicense, and/or sell copies of the Materials, and to
     ** permit persons to whom the Materials are furnished to do so, subject to
     ** the following conditions:
     **
     ** The above copyright notice and this permission notice shall be included
     ** in all copies or substantial portions of the Materials.
     **
     ** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     ** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     ** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     ** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     ** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
     ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
     ** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
     */

    var CONSOLE = (1, eval)("console")

    function enableJSTestPreVerboseLogging() {}

    function initTestingHarnessWaitUntilDone() {}

    function initTestingHarness() {}

    function nonKhronosFrameworkNotifyDone() {
        // WebKit Specific code. Add your code here.
        ENVIRONMENT.tape.end()
    }

    function reportTestResultsToHarness(success, msg) {
        //Garbage
    }

    function notifyFinishedToHarness() {
        ENVIRONMENT.tape.end()
    }

    function description(msg) {
        CONSOLE.log("DESCRIPTION:", msg)
    }

    function debug(msg) {
        CONSOLE.log("DEBUG:", msg)
    }

    function escapeHTML(text) {
        return text.replace(/&/g, "&amp;").replace(/</g, "&lt;");
    }

    function testPassed(msg) {
        ENVIRONMENT.tape.pass(msg)
    }

    function testFailed(msg) {
        ENVIRONMENT.tape.fail(msg)
    }

    function areArraysEqual(_a, _b) {
        try {
            if (_a.length !== _b.length)
                return false;
            for (var i = 0; i < _a.length; i++)
                if (_a[i] !== _b[i])
                    return false;
        } catch (ex) {
            return false;
        }
        return true;
    }

    function isMinusZero(n) {
        // the only way to tell 0 from -0 in JS is the fact that 1/-0 is
        // -Infinity instead of Infinity
        return n === 0 && 1 / n < 0;
    }

    function isResultCorrect(_actual, _expected) {
        if (_expected === 0)
            return _actual === _expected && (1 / _actual) === (1 / _expected);
        if (_actual === _expected)
            return true;
        if (typeof(_expected) == "number" && isNaN(_expected))
            return typeof(_actual) == "number" && isNaN(_actual);
        if (Object.prototype.toString.call(_expected) == Object.prototype.toString.call([]))
            return areArraysEqual(_actual, _expected);
        return false;
    }

    function stringify(v) {
        if (v === 0 && 1 / v < 0)
            return "-0";
        else return "" + v;
    }

    function evalAndLog(_a) {
        if (typeof _a != "string")
            debug("WARN: tryAndLog() expects a string argument");

        // Log first in case things go horribly wrong or this causes a sync event.
        debug(_a);

        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            testFailed(_a + " threw exception " + e);
        }
        return _av;
    }

    function shouldBe(_a, _b, quiet) {
        if (typeof _a != "string" || typeof _b != "string")
            debug("WARN: shouldBe() expects string arguments");
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }
        var _bv = eval(_b);

        if (exception)
            testFailed(_a + " should be " + _bv + ". Threw exception " + exception);
        else if (isResultCorrect(_av, _bv)) {
            if (!quiet) {
                testPassed(_a + " is " + _b);
            }
        } else if (typeof(_av) == typeof(_bv))
            testFailed(_a + " should be " + _bv + ". Was " + stringify(_av) + ".");
        else
            testFailed(_a + " should be " + _bv + " (of type " + typeof _bv + "). Was " + _av + " (of type " + typeof _av + ").");
    }

    function shouldNotBe(_a, _b, quiet) {
        if (typeof _a != "string" || typeof _b != "string")
            debug("WARN: shouldNotBe() expects string arguments");
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }
        var _bv = eval(_b);

        if (exception)
            testFailed(_a + " should not be " + _bv + ". Threw exception " + exception);
        else if (!isResultCorrect(_av, _bv)) {
            if (!quiet) {
                testPassed(_a + " is not " + _b);
            }
        } else
            testFailed(_a + " should not be " + _bv + ".");
    }

    function shouldBeTrue(_a) {
        shouldBe(_a, "true");
    }

    function shouldBeFalse(_a) {
        shouldBe(_a, "false");
    }

    function shouldBeNaN(_a) {
        shouldBe(_a, "NaN");
    }

    function shouldBeNull(_a) {
        shouldBe(_a, "null");
    }

    function shouldBeEqualToString(a, b) {
        var unevaledString = '"' + b.replace(/"/g, "\"") + '"';
        shouldBe(a, unevaledString);
    }

    function shouldEvaluateTo(actual, expected) {
        // A general-purpose comparator.  'actual' should be a string to be
        // evaluated, as for shouldBe(). 'expected' may be any type and will be
        // used without being eval'ed.
        if (expected == null) {
            // Do this before the object test, since null is of type 'object'.
            shouldBeNull(actual);
        } else if (typeof expected == "undefined") {
            shouldBeUndefined(actual);
        } else if (typeof expected == "function") {
            // All this fuss is to avoid the string-arg warning from shouldBe().
            try {
                actualValue = eval(actual);
            } catch (e) {
                testFailed("Evaluating " + actual + ": Threw exception " + e);
                return;
            }
            shouldBe("'" + actualValue.toString().replace(/\n/g, "") + "'",
                "'" + expected.toString().replace(/\n/g, "") + "'");
        } else if (typeof expected == "object") {
            shouldBeTrue(actual + " == '" + expected + "'");
        } else if (typeof expected == "string") {
            shouldBe(actual, expected);
        } else if (typeof expected == "boolean") {
            shouldBe("typeof " + actual, "'boolean'");
            if (expected)
                shouldBeTrue(actual);
            else
                shouldBeFalse(actual);
        } else if (typeof expected == "number") {
            shouldBe(actual, stringify(expected));
        } else {
            debug(expected + " is unknown type " + typeof expected);
            shouldBeTrue(actual, "'" + expected.toString() + "'");
        }
    }

    function shouldBeNonZero(_a) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        if (exception)
            testFailed(_a + " should be non-zero. Threw exception " + exception);
        else if (_av != 0)
            testPassed(_a + " is non-zero.");
        else
            testFailed(_a + " should be non-zero. Was " + _av);
    }

    function shouldBeNonNull(_a) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        if (exception)
            testFailed(_a + " should be non-null. Threw exception " + exception);
        else if (_av != null)
            testPassed(_a + " is non-null.");
        else
            testFailed(_a + " should be non-null. Was " + _av);
    }

    function shouldBeUndefined(_a) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        if (exception)
            testFailed(_a + " should be undefined. Threw exception " + exception);
        else if (typeof _av == "undefined")
            testPassed(_a + " is undefined.");
        else
            testFailed(_a + " should be undefined. Was " + _av);
    }

    function shouldBeDefined(_a) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        if (exception)
            testFailed(_a + " should be defined. Threw exception " + exception);
        else if (_av !== undefined)
            testPassed(_a + " is defined.");
        else
            testFailed(_a + " should be defined. Was " + _av);
    }

    function shouldBeGreaterThanOrEqual(_a, _b) {
        if (typeof _a != "string" || typeof _b != "string")
            debug("WARN: shouldBeGreaterThanOrEqual expects string arguments");

        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }
        var _bv = eval(_b);

        if (exception)
            testFailed(_a + " should be >= " + _b + ". Threw exception " + exception);
        else if (typeof _av == "undefined" || _av < _bv)
            testFailed(_a + " should be >= " + _b + ". Was " + _av + " (of type " + typeof _av + ").");
        else
            testPassed(_a + " is >= " + _b);
    }

    function expectTrue(v, msg) {
        if (v) {
            testPassed(msg);
        } else {
            testFailed(msg);
        }
    }

    function shouldThrow(_a, _e) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        var _ev;
        if (_e)
            _ev = eval(_e);

        if (exception) {
            if (typeof _e == "undefined" || exception == _ev)
                testPassed(_a + " threw exception " + exception + ".");
            else
                testFailed(_a + " should throw " + (typeof _e == "undefined" ? "an exception" : _ev) + ". Threw exception " + exception + ".");
        } else if (typeof _av == "undefined")
            testFailed(_a + " should throw " + (typeof _e == "undefined" ? "an exception" : _ev) + ". Was undefined.");
        else
            testFailed(_a + " should throw " + (typeof _e == "undefined" ? "an exception" : _ev) + ". Was " + _av + ".");
    }

    function shouldBeType(_a, _type) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        var _typev = eval(_type);

        if (_av instanceof _typev) {
            testPassed(_a + " is an instance of " + _type);
        } else {
            testFailed(_a + " is not an instance of " + _type);
        }
    }

    function assertMsg(assertion, msg) {
        if (assertion) {
            testPassed(msg);
        } else {
            testFailed(msg);
        }
    }

    function gc() {}

    function finishTest() {
        ENVIRONMENT.tape.end()
    };;
    TestEval = function(str) {
        return eval(str);
    };;;
    ENVIRONMENT.postHook = function() {
        ENVIRONMENT.tape.end()
    };


    /******************* BEGIN TEST CASE *******************/




    "use strict";
    description("Test DataView.");

    var intArray1 = [0, 1, 2, 3, 100, 101, 102, 103, 128, 129, 130, 131, 252, 253, 254, 255];
    var intArray2 = [31, 32, 33, 0, 1, 2, 3, 100, 101, 102, 103, 128, 129, 130, 131, 252, 253, 254, 255];
    var emptyArray = [204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204];

    var arrayBuffer = null;
    var view = null;
    var viewStart = 0;
    var viewLength = 0;

    function getElementSize(func) {
        switch (func) {
            case "Int8":
            case "Uint8":
                return 1;
            case "Int16":
            case "Uint16":
                return 2;
            case "Int32":
            case "Uint32":
            case "Float32":
                return 4;
            case "Float64":
                return 8;
            default:
                debug("Should not reached");
        }
    }

    function checkGet(func, index, expected, littleEndian) {
        var expr = "view.get" + func + "(" + index;
        if (littleEndian != undefined) {
            expr += ", ";
            expr += littleEndian ? "true" : "false";
        }
        expr += ")";
        if (index >= 0 && index + getElementSize(func) - 1 < view.byteLength)
            shouldBe(expr, expected);
        else
            shouldThrow(expr);
    }

    function checkSet(func, index, value, littleEndian) {
        var expr = "view.set" + func + "(" + index + ", " + value;
        if (littleEndian != undefined) {
            expr += ", ";
            expr += littleEndian ? "true" : "false";
        }
        expr += ")";
        if (index >= 0 && index + getElementSize(func) - 1 < view.byteLength) {
            shouldBeUndefined(expr);
            checkGet(func, index, value, littleEndian);
        } else
            shouldThrow(expr);
    }

    function test(isTestingGet, func, index, value, littleEndian) {
        if (isTestingGet)
            checkGet(func, index, value, littleEndian);
        else
            checkSet(func, index, value, littleEndian);
    }

    function createDataView(array, frontPaddingNum, littleEndian, start, length) {
        if (!littleEndian)
            array.reverse();
        var paddingArray = new Array(frontPaddingNum);
        arrayBuffer = (new Uint8Array(paddingArray.concat(array))).buffer;
        viewStart = (start != undefined) ? start : 0;
        viewLength = (length != undefined) ? length : arrayBuffer.byteLength - viewStart;
        view = new DataView(arrayBuffer, viewStart, viewLength);
        if (!littleEndian)
            array.reverse(); // restore the array.
    }

    function runIntegerTestCases(isTestingGet, array, start, length) {
        createDataView(array, 0, true, start, length);

        test(isTestingGet, "Int8", 0, "0");
        test(isTestingGet, "Int8", 8, "-128");
        test(isTestingGet, "Int8", 15, "-1");

        test(isTestingGet, "Uint8", 0, "0");
        test(isTestingGet, "Uint8", 8, "128");
        test(isTestingGet, "Uint8", 15, "255");

        // Little endian.
        test(isTestingGet, "Int16", 0, "256", true);
        test(isTestingGet, "Int16", 5, "26213", true);
        test(isTestingGet, "Int16", 9, "-32127", true);
        test(isTestingGet, "Int16", 14, "-2", true);

        // Big endian.
        test(isTestingGet, "Int16", 0, "1");
        test(isTestingGet, "Int16", 5, "25958");
        test(isTestingGet, "Int16", 9, "-32382");
        test(isTestingGet, "Int16", 14, "-257");

        // Little endian.
        test(isTestingGet, "Uint16", 0, "256", true);
        test(isTestingGet, "Uint16", 5, "26213", true);
        test(isTestingGet, "Uint16", 9, "33409", true);
        test(isTestingGet, "Uint16", 14, "65534", true);

        // Big endian.
        test(isTestingGet, "Uint16", 0, "1");
        test(isTestingGet, "Uint16", 5, "25958");
        test(isTestingGet, "Uint16", 9, "33154");
        test(isTestingGet, "Uint16", 14, "65279");

        // Little endian.
        test(isTestingGet, "Int32", 0, "50462976", true);
        test(isTestingGet, "Int32", 3, "1717920771", true);
        test(isTestingGet, "Int32", 6, "-2122291354", true);
        test(isTestingGet, "Int32", 9, "-58490239", true);
        test(isTestingGet, "Int32", 12, "-66052", true);

        // Big endian.
        test(isTestingGet, "Int32", 0, "66051");
        test(isTestingGet, "Int32", 3, "56911206");
        test(isTestingGet, "Int32", 6, "1718059137");
        test(isTestingGet, "Int32", 9, "-2122152964");
        test(isTestingGet, "Int32", 12, "-50462977");

        // Little endian.
        test(isTestingGet, "Uint32", 0, "50462976", true);
        test(isTestingGet, "Uint32", 3, "1717920771", true);
        test(isTestingGet, "Uint32", 6, "2172675942", true);
        test(isTestingGet, "Uint32", 9, "4236477057", true);
        test(isTestingGet, "Uint32", 12, "4294901244", true);

        // Big endian.
        test(isTestingGet, "Uint32", 0, "66051");
        test(isTestingGet, "Uint32", 3, "56911206");
        test(isTestingGet, "Uint32", 6, "1718059137");
        test(isTestingGet, "Uint32", 9, "2172814332");
        test(isTestingGet, "Uint32", 12, "4244504319");
    }

    function testFloat(isTestingGet, func, array, start, expected) {
        // Little endian.
        createDataView(array, 0, true, start);
        test(isTestingGet, func, 0, expected, true);
        createDataView(array, 3, true, start);
        test(isTestingGet, func, 3, expected, true);
        createDataView(array, 7, true, start);
        test(isTestingGet, func, 7, expected, true);
        createDataView(array, 10, true, start);
        test(isTestingGet, func, 10, expected, true);

        // Big endian.
        createDataView(array, 0, false);
        test(isTestingGet, func, 0, expected, false);
        createDataView(array, 3, false);
        test(isTestingGet, func, 3, expected, false);
        createDataView(array, 7, false);
        test(isTestingGet, func, 7, expected, false);
        createDataView(array, 10, false);
        test(isTestingGet, func, 10, expected, false);
    }

    function runFloatTestCases(isTestingGet, start) {
        testFloat(isTestingGet, "Float32", isTestingGet ? [0, 0, 32, 65] : emptyArray, start, "10");
        testFloat(isTestingGet, "Float32", isTestingGet ? [164, 112, 157, 63] : emptyArray, start, "1.2300000190734863");
        testFloat(isTestingGet, "Float32", isTestingGet ? [95, 53, 50, 199] : emptyArray, start, "-45621.37109375");
        testFloat(isTestingGet, "Float32", isTestingGet ? [255, 255, 255, 127] : emptyArray, start, "NaN");
        testFloat(isTestingGet, "Float32", isTestingGet ? [255, 255, 255, 255] : emptyArray, start, "-NaN");

        testFloat(isTestingGet, "Float64", isTestingGet ? [0, 0, 0, 0, 0, 0, 36, 64] : emptyArray, start, "10");
        testFloat(isTestingGet, "Float64", isTestingGet ? [174, 71, 225, 122, 20, 174, 243, 63] : emptyArray, start, "1.23");
        testFloat(isTestingGet, "Float64", isTestingGet ? [181, 55, 248, 30, 242, 179, 87, 193] : emptyArray, start, "-6213576.4839");
        testFloat(isTestingGet, "Float64", isTestingGet ? [255, 255, 255, 255, 255, 255, 255, 127] : emptyArray, start, "NaN");
        testFloat(isTestingGet, "Float64", isTestingGet ? [255, 255, 255, 255, 255, 255, 255, 255] : emptyArray, start, "-NaN");
    }

    function runNegativeIndexTests(isTestingGet) {
        createDataView(intArray1, 0, true, 0, 16);

        test(isTestingGet, "Int8", -1, "0");
        test(isTestingGet, "Int8", -2, "0");

        test(isTestingGet, "Uint8", -1, "0");
        test(isTestingGet, "Uint8", -2, "0");

        test(isTestingGet, "Int16", -1, "0");
        test(isTestingGet, "Int16", -2, "0");
        test(isTestingGet, "Int16", -3, "0");

        test(isTestingGet, "Uint16", -1, "0");
        test(isTestingGet, "Uint16", -2, "0");
        test(isTestingGet, "Uint16", -3, "0");

        test(isTestingGet, "Int32", -1, "0");
        test(isTestingGet, "Int32", -3, "0");
        test(isTestingGet, "Int32", -5, "0");

        test(isTestingGet, "Uint32", -1, "0");
        test(isTestingGet, "Uint32", -3, "0");
        test(isTestingGet, "Uint32", -5, "0");

        createDataView([0, 0, 0, 0, 0, 0, 36, 64], 0, true, 0, 8);

        test(isTestingGet, "Float32", -1, "0");
        test(isTestingGet, "Float32", -3, "0");
        test(isTestingGet, "Float32", -5, "0");

        test(isTestingGet, "Float64", -1, "0");
        test(isTestingGet, "Float64", -5, "0");
        test(isTestingGet, "Float64", -9, "0");
    }

    function runConstructorTests() {
        arrayBuffer = (new Uint8Array([1, 2])).buffer;

        debug("");
        debug("Test for constructor taking 1 argument");
        shouldBeDefined("view = new DataView(arrayBuffer)");
        shouldBe("view.byteOffset", "0");
        shouldBe("view.byteLength", "2");

        debug("");
        debug("Test for constructor taking 2 arguments");
        shouldBeDefined("view = new DataView(arrayBuffer, 1)");
        shouldBe("view.byteOffset", "1");
        shouldBe("view.byteLength", "1");

        debug("");
        debug("Test for constructor taking 3 arguments");
        shouldBeDefined("view = new DataView(arrayBuffer, 0, 1)");
        shouldBe("view.byteOffset", "0");
        shouldBe("view.byteLength", "1");

        debug("");
        debug("Test for constructor throwing exception");
        shouldThrow("view = new DataView(arrayBuffer, 0, 3)");
        shouldThrow("view = new DataView(arrayBuffer, 1, 2)");
        shouldThrow("view = new DataView(arrayBuffer, 2, 1)");
    }

    function runGetTests() {
        debug("");
        debug("Test for get methods that work");
        runIntegerTestCases(true, intArray1, 0, 16);
        runFloatTestCases(true, 0);

        debug("");
        debug("Test for get methods that might read beyond range");
        runIntegerTestCases(true, intArray2, 3, 2);
        runFloatTestCases(true, 3);

        debug("");
        debug("Test for get methods that read from negative index");
        runNegativeIndexTests(true);

        debug("");
        debug("Test for wrong arguments passed to get methods");
        view = new DataView((new Uint8Array([1, 2])).buffer);
        shouldThrow("view.getInt8()");
        shouldThrow("view.getUint8()");
        shouldThrow("view.getInt16()");
        shouldThrow("view.getUint16()");
        shouldThrow("view.getInt32()");
        shouldThrow("view.getUint32()");
        shouldThrow("view.getFloat32()");
        shouldThrow("view.getFloat64()");
    }

    function runSetTests() {
        debug("");
        debug("Test for set methods that work");
        runIntegerTestCases(false, emptyArray, 0, 16);
        runFloatTestCases(false);

        debug("");
        debug("Test for set methods that might write beyond the range");
        runIntegerTestCases(false, emptyArray, 3, 2);
        runFloatTestCases(false, 7);

        debug("");
        debug("Test for set methods that write to negative index");
        runNegativeIndexTests(false);

        debug("");
        debug("Test for wrong arguments passed to set methods");
        view = new DataView((new Uint8Array([1, 2])).buffer);
        shouldThrow("view.setInt8()");
        shouldThrow("view.setUint8()");
        shouldThrow("view.setInt16()");
        shouldThrow("view.setUint16()");
        shouldThrow("view.setInt32()");
        shouldThrow("view.setUint32()");
        shouldThrow("view.setFloat32()");
        shouldThrow("view.setFloat64()");
        shouldThrow("view.setInt8(1)");
        shouldThrow("view.setUint8(1)");
        shouldThrow("view.setInt16(1)");
        shouldThrow("view.setUint16(1)");
        shouldThrow("view.setInt32(1)");
        shouldThrow("view.setUint32(1)");
        shouldThrow("view.setFloat32(1)");
        shouldThrow("view.setFloat64(1)");
    }

    function runIndexingTests() {
        debug("");
        debug("Test for indexing that should not work");
        view = new DataView((new Uint8Array([1, 2])).buffer);
        shouldBeUndefined("view[0]");
        shouldBeDefined("view[0] = 3");
        shouldBe("view.getUint8(0)", "1");
    }

    runConstructorTests();
    runGetTests();
    runSetTests();
    runIndexingTests();
    var successfullyParsed = true;;


    /******************* END TEST CASE *******************/



    if (ENVIRONMENT.postHook) {
        ENVIRONMENT.postHook();
    }
};
module.exports = typedarrays_data_view_test