/*eslint-disable */
var _windowShim = require("../lib/shims/window-shim");
var _documentShim = require("../lib/shims/document-shim");
var _canvasShim = require("../lib/shims/canvas-shim");
var _imageShim = require("../lib/shims/image-shim");
var _rafShim = require("../lib/shims/raf-shim");
var _RESOURCES = require("./resources.json");

function context_constants_and_properties(ENVIRONMENT) {
    var HTMLElement = function() {};
    ENVIRONMENT.CONTEXT_LIST = [];
    ENVIRONMENT.tape.end = (function(tape_end) {
        return function() {
            _rafShim.clear();
            ENVIRONMENT.CONTEXT_LIST.forEach(function(gl) {
                (gl.destroy && gl.destroy());
            });
            ENVIRONMENT.CONTEXT_LIST = [];
            tape_end.call(ENVIRONMENT.tape);
        }
    })(ENVIRONMENT.tape.end);
    ENVIRONMENT._createContext = ENVIRONMENT.createContext;
    ENVIRONMENT.createContext = function(w, h, o) {
        var gl = ENVIRONMENT._createContext(w, h, o);
        ENVIRONMENT.CONTEXT_LIST.push(gl);
        return gl;
    };
    ENVIRONMENT.document = _documentShim(ENVIRONMENT);
    ENVIRONMENT.window = _windowShim(ENVIRONMENT);
    ENVIRONMENT.scriptList = {};
    ENVIRONMENT.canvasList = [{
        "id": "canvas"
    }].map(function(opts) {
        return _canvasShim(ENVIRONMENT, opts);
    });
    ENVIRONMENT.RESOURCES = _RESOURCES;
    ENVIRONMENT.BASEPATH = "context";
    var document = ENVIRONMENT.document;
    var window = ENVIRONMENT.window;
    var Image = _imageShim;
    var requestAnimationFrame = _rafShim.requestAnimationFrame;
    var cancelAnimationFrame = _rafShim.cancelAnimationFrame;;
    /*
     ** Copyright (c) 2012 The Khronos Group Inc.
     **
     ** Permission is hereby granted, free of charge, to any person obtaining a
     ** copy of this software and/or associated documentation files (the
     ** "Materials"), to deal in the Materials without restriction, including
     ** without limitation the rights to use, copy, modify, merge, publish,
     ** distribute, sublicense, and/or sell copies of the Materials, and to
     ** permit persons to whom the Materials are furnished to do so, subject to
     ** the following conditions:
     **
     ** The above copyright notice and this permission notice shall be included
     ** in all copies or substantial portions of the Materials.
     **
     ** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     ** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     ** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     ** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     ** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
     ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
     ** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
     */

    var CONSOLE = (1, eval)("console")

    function enableJSTestPreVerboseLogging() {}

    function initTestingHarnessWaitUntilDone() {}

    function initTestingHarness() {}

    function nonKhronosFrameworkNotifyDone() {
        // WebKit Specific code. Add your code here.
        ENVIRONMENT.tape.end()
    }

    function reportTestResultsToHarness(success, msg) {
        //Garbage
    }

    function notifyFinishedToHarness() {
        ENVIRONMENT.tape.end()
    }

    function description(msg) {
        CONSOLE.log("DESCRIPTION:", msg)
    }

    function debug(msg) {
        CONSOLE.log("DEBUG:", msg)
    }

    function escapeHTML(text) {
        return text.replace(/&/g, "&amp;").replace(/</g, "&lt;");
    }

    function testPassed(msg) {
        ENVIRONMENT.tape.pass(msg)
    }

    function testFailed(msg) {
        ENVIRONMENT.tape.fail(msg)
    }

    function areArraysEqual(_a, _b) {
        try {
            if (_a.length !== _b.length)
                return false;
            for (var i = 0; i < _a.length; i++)
                if (_a[i] !== _b[i])
                    return false;
        } catch (ex) {
            return false;
        }
        return true;
    }

    function isMinusZero(n) {
        // the only way to tell 0 from -0 in JS is the fact that 1/-0 is
        // -Infinity instead of Infinity
        return n === 0 && 1 / n < 0;
    }

    function isResultCorrect(_actual, _expected) {
        if (_expected === 0)
            return _actual === _expected && (1 / _actual) === (1 / _expected);
        if (_actual === _expected)
            return true;
        if (typeof(_expected) == "number" && isNaN(_expected))
            return typeof(_actual) == "number" && isNaN(_actual);
        if (Object.prototype.toString.call(_expected) == Object.prototype.toString.call([]))
            return areArraysEqual(_actual, _expected);
        return false;
    }

    function stringify(v) {
        if (v === 0 && 1 / v < 0)
            return "-0";
        else return "" + v;
    }

    function evalAndLog(_a) {
        if (typeof _a != "string")
            debug("WARN: tryAndLog() expects a string argument");

        // Log first in case things go horribly wrong or this causes a sync event.
        debug(_a);

        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            testFailed(_a + " threw exception " + e);
        }
        return _av;
    }

    function shouldBe(_a, _b, quiet) {
        if (typeof _a != "string" || typeof _b != "string")
            debug("WARN: shouldBe() expects string arguments");
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }
        var _bv = eval(_b);

        if (exception)
            testFailed(_a + " should be " + _bv + ". Threw exception " + exception);
        else if (isResultCorrect(_av, _bv)) {
            if (!quiet) {
                testPassed(_a + " is " + _b);
            }
        } else if (typeof(_av) == typeof(_bv))
            testFailed(_a + " should be " + _bv + ". Was " + stringify(_av) + ".");
        else
            testFailed(_a + " should be " + _bv + " (of type " + typeof _bv + "). Was " + _av + " (of type " + typeof _av + ").");
    }

    function shouldNotBe(_a, _b, quiet) {
        if (typeof _a != "string" || typeof _b != "string")
            debug("WARN: shouldNotBe() expects string arguments");
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }
        var _bv = eval(_b);

        if (exception)
            testFailed(_a + " should not be " + _bv + ". Threw exception " + exception);
        else if (!isResultCorrect(_av, _bv)) {
            if (!quiet) {
                testPassed(_a + " is not " + _b);
            }
        } else
            testFailed(_a + " should not be " + _bv + ".");
    }

    function shouldBeTrue(_a) {
        shouldBe(_a, "true");
    }

    function shouldBeFalse(_a) {
        shouldBe(_a, "false");
    }

    function shouldBeNaN(_a) {
        shouldBe(_a, "NaN");
    }

    function shouldBeNull(_a) {
        shouldBe(_a, "null");
    }

    function shouldBeEqualToString(a, b) {
        var unevaledString = '"' + b.replace(/"/g, "\"") + '"';
        shouldBe(a, unevaledString);
    }

    function shouldEvaluateTo(actual, expected) {
        // A general-purpose comparator.  'actual' should be a string to be
        // evaluated, as for shouldBe(). 'expected' may be any type and will be
        // used without being eval'ed.
        if (expected == null) {
            // Do this before the object test, since null is of type 'object'.
            shouldBeNull(actual);
        } else if (typeof expected == "undefined") {
            shouldBeUndefined(actual);
        } else if (typeof expected == "function") {
            // All this fuss is to avoid the string-arg warning from shouldBe().
            try {
                actualValue = eval(actual);
            } catch (e) {
                testFailed("Evaluating " + actual + ": Threw exception " + e);
                return;
            }
            shouldBe("'" + actualValue.toString().replace(/\n/g, "") + "'",
                "'" + expected.toString().replace(/\n/g, "") + "'");
        } else if (typeof expected == "object") {
            shouldBeTrue(actual + " == '" + expected + "'");
        } else if (typeof expected == "string") {
            shouldBe(actual, expected);
        } else if (typeof expected == "boolean") {
            shouldBe("typeof " + actual, "'boolean'");
            if (expected)
                shouldBeTrue(actual);
            else
                shouldBeFalse(actual);
        } else if (typeof expected == "number") {
            shouldBe(actual, stringify(expected));
        } else {
            debug(expected + " is unknown type " + typeof expected);
            shouldBeTrue(actual, "'" + expected.toString() + "'");
        }
    }

    function shouldBeNonZero(_a) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        if (exception)
            testFailed(_a + " should be non-zero. Threw exception " + exception);
        else if (_av != 0)
            testPassed(_a + " is non-zero.");
        else
            testFailed(_a + " should be non-zero. Was " + _av);
    }

    function shouldBeNonNull(_a) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        if (exception)
            testFailed(_a + " should be non-null. Threw exception " + exception);
        else if (_av != null)
            testPassed(_a + " is non-null.");
        else
            testFailed(_a + " should be non-null. Was " + _av);
    }

    function shouldBeUndefined(_a) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        if (exception)
            testFailed(_a + " should be undefined. Threw exception " + exception);
        else if (typeof _av == "undefined")
            testPassed(_a + " is undefined.");
        else
            testFailed(_a + " should be undefined. Was " + _av);
    }

    function shouldBeDefined(_a) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        if (exception)
            testFailed(_a + " should be defined. Threw exception " + exception);
        else if (_av !== undefined)
            testPassed(_a + " is defined.");
        else
            testFailed(_a + " should be defined. Was " + _av);
    }

    function shouldBeGreaterThanOrEqual(_a, _b) {
        if (typeof _a != "string" || typeof _b != "string")
            debug("WARN: shouldBeGreaterThanOrEqual expects string arguments");

        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }
        var _bv = eval(_b);

        if (exception)
            testFailed(_a + " should be >= " + _b + ". Threw exception " + exception);
        else if (typeof _av == "undefined" || _av < _bv)
            testFailed(_a + " should be >= " + _b + ". Was " + _av + " (of type " + typeof _av + ").");
        else
            testPassed(_a + " is >= " + _b);
    }

    function expectTrue(v, msg) {
        if (v) {
            testPassed(msg);
        } else {
            testFailed(msg);
        }
    }

    function shouldThrow(_a, _e) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        var _ev;
        if (_e)
            _ev = eval(_e);

        if (exception) {
            if (typeof _e == "undefined" || exception == _ev)
                testPassed(_a + " threw exception " + exception + ".");
            else
                testFailed(_a + " should throw " + (typeof _e == "undefined" ? "an exception" : _ev) + ". Threw exception " + exception + ".");
        } else if (typeof _av == "undefined")
            testFailed(_a + " should throw " + (typeof _e == "undefined" ? "an exception" : _ev) + ". Was undefined.");
        else
            testFailed(_a + " should throw " + (typeof _e == "undefined" ? "an exception" : _ev) + ". Was " + _av + ".");
    }

    function shouldBeType(_a, _type) {
        var exception;
        var _av;
        try {
            _av = eval(_a);
        } catch (e) {
            exception = e;
        }

        var _typev = eval(_type);

        if (_av instanceof _typev) {
            testPassed(_a + " is an instance of " + _type);
        } else {
            testFailed(_a + " is not an instance of " + _type);
        }
    }

    function assertMsg(assertion, msg) {
        if (assertion) {
            testPassed(msg);
        } else {
            testFailed(msg);
        }
    }

    function gc() {}

    function finishTest() {
        ENVIRONMENT.tape.end()
    };;
    /*
     ** Copyright (c) 2012 The Khronos Group Inc.
     **
     ** Permission is hereby granted, free of charge, to any person obtaining a
     ** copy of this software and/or associated documentation files (the
     ** "Materials"), to deal in the Materials without restriction, including
     ** without limitation the rights to use, copy, modify, merge, publish,
     ** distribute, sublicense, and/or sell copies of the Materials, and to
     ** permit persons to whom the Materials are furnished to do so, subject to
     ** the following conditions:
     **
     ** The above copyright notice and this permission notice shall be included
     ** in all copies or substantial portions of the Materials.
     **
     ** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     ** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     ** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     ** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     ** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
     ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
     ** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
     */

    var canvas = null

    function createTestUtils() {

        "use strict"

        var console = (1, eval)("console")
        var path = require("path").posix

        /**
         * Wrapped logging function.
         * @param {string} msg The message to log.
         */
        var log = function(msg) {
            console.log(msg)
        };

        /**
         * Wrapped logging function.
         * @param {string} msg The message to log.
         */
        var error = function(msg) {
            console.log(msg)
        };

        /**
         * Turn off all logging.
         */
        var loggingOff = function() {
            log = function() {};
            error = function() {};
        };

        /**
         * Converts a WebGL enum to a string
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} value The enum value.
         * @return {string} The enum as a string.
         */
        var glEnumToString = function(gl, value) {
            for (var p in gl) {
                if (gl[p] == value) {
                    return p;
                }
            }
            return "0x" + value.toString(16);
        };

        var lastError = "";

        /**
         * Returns the last compiler/linker error.
         * @return {string} The last compiler/linker error.
         */
        var getLastError = function() {
            return lastError;
        };

        /**
         * Whether a haystack ends with a needle.
         * @param {string} haystack String to search
         * @param {string} needle String to search for.
         * @param {boolean} True if haystack ends with needle.
         */
        var endsWith = function(haystack, needle) {
            return haystack.substr(haystack.length - needle.length) === needle;
        };

        /**
         * Whether a haystack starts with a needle.
         * @param {string} haystack String to search
         * @param {string} needle String to search for.
         * @param {boolean} True if haystack starts with needle.
         */
        var startsWith = function(haystack, needle) {
            return haystack.substr(0, needle.length) === needle;
        };

        /**
         * A vertex shader for a single texture.
         * @type {string}
         */
        var simpleTextureVertexShader = [
            'attribute vec4 vPosition;',
            'attribute vec2 texCoord0;',
            'varying vec2 texCoord;',
            'void main() {',
            '    gl_Position = vPosition;',
            '    texCoord = texCoord0;',
            '}'
        ].join('\n');

        /**
         * A fragment shader for a single texture.
         * @type {string}
         */
        var simpleTextureFragmentShader = [
            'precision mediump float;',
            'uniform sampler2D tex;',
            'varying vec2 texCoord;',
            'void main() {',
            '    gl_FragData[0] = texture2D(tex, texCoord);',
            '}'
        ].join('\n');

        /**
         * A vertex shader for a single texture.
         * @type {string}
         */
        var noTexCoordTextureVertexShader = [
            'attribute vec4 vPosition;',
            'varying vec2 texCoord;',
            'void main() {',
            '    gl_Position = vPosition;',
            '    texCoord = vPosition.xy * 0.5 + 0.5;',
            '}'
        ].join('\n');

        /**
         * A vertex shader for a uniform color.
         * @type {string}
         */
        var simpleColorVertexShader = [
            'attribute vec4 vPosition;',
            'void main() {',
            '    gl_Position = vPosition;',
            '}'
        ].join('\n');

        /**
         * A fragment shader for a uniform color.
         * @type {string}
         */
        var simpleColorFragmentShader = [
            'precision mediump float;',
            'uniform vec4 u_color;',
            'void main() {',
            '    gl_FragData[0] = u_color;',
            '}'
        ].join('\n');

        /**
         * A vertex shader for vertex colors.
         * @type {string}
         */
        var simpleVertexColorVertexShader = [
            'attribute vec4 vPosition;',
            'attribute vec4 a_color;',
            'varying vec4 v_color;',
            'void main() {',
            '    gl_Position = vPosition;',
            '    v_color = a_color;',
            '}'
        ].join('\n');

        /**
         * A fragment shader for vertex colors.
         * @type {string}
         */
        var simpleVertexColorFragmentShader = [
            'precision mediump float;',
            'varying vec4 v_color;',
            'void main() {',
            '    gl_FragData[0] = v_color;',
            '}'
        ].join('\n');

        /**
         * Creates a simple texture vertex shader.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {!WebGLShader}
         */
        var setupSimpleTextureVertexShader = function(gl) {
            return loadShader(gl, simpleTextureVertexShader, gl.VERTEX_SHADER);
        };

        /**
         * Creates a simple texture fragment shader.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {!WebGLShader}
         */
        var setupSimpleTextureFragmentShader = function(gl) {
            return loadShader(
                gl, simpleTextureFragmentShader, gl.FRAGMENT_SHADER);
        };

        /**
         * Creates a texture vertex shader that doesn't need texcoords.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {!WebGLShader}
         */
        var setupNoTexCoordTextureVertexShader = function(gl) {
            return loadShader(gl, noTexCoordTextureVertexShader, gl.VERTEX_SHADER);
        };

        /**
         * Creates a simple vertex color vertex shader.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {!WebGLShader}
         */
        var setupSimpleVertexColorVertexShader = function(gl) {
            return loadShader(gl, simpleVertexColorVertexShader, gl.VERTEX_SHADER);
        };

        /**
         * Creates a simple vertex color fragment shader.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {!WebGLShader}
         */
        var setupSimpleVertexColorFragmentShader = function(gl) {
            return loadShader(
                gl, simpleVertexColorFragmentShader, gl.FRAGMENT_SHADER);
        };

        /**
         * Creates a simple color vertex shader.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {!WebGLShader}
         */
        var setupSimpleColorVertexShader = function(gl) {
            return loadShader(gl, simpleColorVertexShader, gl.VERTEX_SHADER);
        };

        /**
         * Creates a simple color fragment shader.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {!WebGLShader}
         */
        var setupSimpleColorFragmentShader = function(gl) {
            return loadShader(
                gl, simpleColorFragmentShader, gl.FRAGMENT_SHADER);
        };

        /**
         * Creates a program, attaches shaders, binds attrib locations, links the
         * program and calls useProgram.
         * @param {!Array.<!WebGLShader|string>} shaders The shaders to
         *        attach, or the source, or the id of a script to get
         *        the source from.
         * @param {!Array.<string>} opt_attribs The attribs names.
         * @param {!Array.<number>} opt_locations The locations for the attribs.
         */
        var setupProgram = function(gl, shaders, opt_attribs, opt_locations) {
            var realShaders = [];
            var program = gl.createProgram();
            var shaderType = undefined;
            for (var ii = 0; ii < shaders.length; ++ii) {
                var shader = shaders[ii];
                if (typeof shader == 'string') {
                    var element = ENVIRONMENT.scriptList[shader];
                    if (element) {
                        if (element.type != "x-shader/x-vertex" && element.type != "x-shader/x-fragment")
                            shaderType = ii ? gl.FRAGMENT_SHADER : gl.VERTEX_SHADER;
                        shader = loadShaderFromScript(gl, shader, shaderType);
                    } else if (endsWith(shader, ".vert")) {
                        shader = loadShaderFromFile(gl, shader, gl.VERTEX_SHADER);
                    } else if (endsWith(shader, ".frag")) {
                        shader = loadShaderFromFile(gl, shader, gl.FRAGMENT_SHADER);
                    } else {
                        shader = loadShader(gl, shader, ii ? gl.FRAGMENT_SHADER : gl.VERTEX_SHADER);
                    }
                }
                gl.attachShader(program, shader);
            }
            if (opt_attribs) {
                for (var ii = 0; ii < opt_attribs.length; ++ii) {
                    gl.bindAttribLocation(
                        program,
                        opt_locations ? opt_locations[ii] : ii,
                        opt_attribs[ii]);
                }
            }
            gl.linkProgram(program);

            // Check the link status
            var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!linked) {
                // something went wrong with the link
                lastError = gl.getProgramInfoLog(program);
                error("Error in program linking:" + lastError);

                gl.deleteProgram(program);
                return null;
            }

            gl.useProgram(program);
            return program;
        };

        /**
         * Creates a simple texture program.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} opt_positionLocation The attrib location for position.
         * @param {number} opt_texcoordLocation The attrib location for texture coords.
         * @return {WebGLProgram}
         */
        var setupSimpleTextureProgram = function(
            gl, opt_positionLocation, opt_texcoordLocation) {
            opt_positionLocation = opt_positionLocation || 0;
            opt_texcoordLocation = opt_texcoordLocation || 1;
            var vs = setupSimpleTextureVertexShader(gl);
            var fs = setupSimpleTextureFragmentShader(gl);
            if (!vs || !fs) {
                return null;
            }
            var program = setupProgram(
                gl, [vs, fs], ['vPosition', 'texCoord0'], [opt_positionLocation, opt_texcoordLocation]);
            if (!program) {
                gl.deleteShader(fs);
                gl.deleteShader(vs);
            }
            gl.useProgram(program);
            return program;
        };

        /**
         * Creates a simple texture program.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @return {WebGLProgram}
         */
        var setupNoTexCoordTextureProgram = function(gl) {
            var vs = setupNoTexCoordTextureVertexShader(gl);
            var fs = setupSimpleTextureFragmentShader(gl);
            if (!vs || !fs) {
                return null;
            }
            var program = setupProgram(
                gl, [vs, fs], ['vPosition'], [0]);
            if (!program) {
                gl.deleteShader(fs);
                gl.deleteShader(vs);
            }
            gl.useProgram(program);
            return program;
        };

        /**
         * Creates a simple texture program.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} opt_positionLocation The attrib location for position.
         * @param {number} opt_texcoordLocation The attrib location for texture coords.
         * @return {WebGLProgram}
         */
        var setupSimpleTextureProgram = function(
            gl, opt_positionLocation, opt_texcoordLocation) {
            opt_positionLocation = opt_positionLocation || 0;
            opt_texcoordLocation = opt_texcoordLocation || 1;
            var vs = setupSimpleTextureVertexShader(gl);
            var fs = setupSimpleTextureFragmentShader(gl);
            if (!vs || !fs) {
                return null;
            }
            var program = setupProgram(
                gl, [vs, fs], ['vPosition', 'texCoord0'], [opt_positionLocation, opt_texcoordLocation]);
            if (!program) {
                gl.deleteShader(fs);
                gl.deleteShader(vs);
            }
            gl.useProgram(program);
            return program;
        };

        /**
         * Creates a simple vertex color program.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} opt_positionLocation The attrib location for position.
         * @param {number} opt_vertexColorLocation The attrib location
         *        for vertex colors.
         * @return {WebGLProgram}
         */
        var setupSimpleVertexColorProgram = function(
            gl, opt_positionLocation, opt_vertexColorLocation) {
            opt_positionLocation = opt_positionLocation || 0;
            opt_vertexColorLocation = opt_vertexColorLocation || 1;
            var vs = setupSimpleVertexColorVertexShader(gl);
            var fs = setupSimpleVertexColorFragmentShader(gl);
            if (!vs || !fs) {
                return null;
            }
            var program = setupProgram(
                gl, [vs, fs], ['vPosition', 'a_color'], [opt_positionLocation, opt_vertexColorLocation]);
            if (!program) {
                gl.deleteShader(fs);
                gl.deleteShader(vs);
            }
            gl.useProgram(program);
            return program;
        };

        /**
         * Creates a simple color program.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} opt_positionLocation The attrib location for position.
         * @return {WebGLProgram}
         */
        var setupSimpleColorProgram = function(gl, opt_positionLocation) {
            opt_positionLocation = opt_positionLocation || 0;
            var vs = setupSimpleColorVertexShader(gl);
            var fs = setupSimpleColorFragmentShader(gl);
            if (!vs || !fs) {
                return null;
            }
            var program = setupProgram(
                gl, [vs, fs], ['vPosition'], [opt_positionLocation]);
            if (!program) {
                gl.deleteShader(fs);
                gl.deleteShader(vs);
            }
            gl.useProgram(program);
            return program;
        };

        /**
         * Creates buffers for a textured unit quad and attaches them to vertex attribs.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {number} opt_positionLocation The attrib location for position.
         * @param {number} opt_texcoordLocation The attrib location for texture coords.
         * @return {!Array.<WebGLBuffer>} The buffer objects that were
         *      created.
         */
        var setupUnitQuad = function(gl, opt_positionLocation, opt_texcoordLocation) {
            return setupUnitQuadWithTexCoords(gl, [0.0, 0.0], [1.0, 1.0],
                opt_positionLocation, opt_texcoordLocation);
        };

        /**
         * Creates buffers for a textured unit quad with specified lower left
         * and upper right texture coordinates, and attaches them to vertex
         * attribs.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {!Array.<number>} lowerLeftTexCoords The texture coordinates for the lower left corner.
         * @param {!Array.<number>} upperRightTexCoords The texture coordinates for the upper right corner.
         * @param {number} opt_positionLocation The attrib location for position.
         * @param {number} opt_texcoordLocation The attrib location for texture coords.
         * @return {!Array.<WebGLBuffer>} The buffer objects that were
         *      created.
         */
        var setupUnitQuadWithTexCoords = function(
            gl, lowerLeftTexCoords, upperRightTexCoords,
            opt_positionLocation, opt_texcoordLocation) {
            return setupQuad(gl, {
                positionLocation: opt_positionLocation || 0,
                texcoordLocation: opt_texcoordLocation || 1,
                lowerLeftTexCoords: lowerLeftTexCoords,
                upperRightTexCoords: upperRightTexCoords,
            });
        };

        /**
         * Makes a quad with various options.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {!Object} options.
         *
         * scale: scale to multiple unit quad values by. default 1.0.
         * positionLocation: attribute location for position.
         * texcoordLocation: attribute location for texcoords.
         *     If this does not exist no texture coords are created.
         * lowerLeftTexCoords: an array of 2 values for the
         *     lowerLeftTexCoords.
         * upperRightTexCoords: an array of 2 values for the
         *     upperRightTexCoords.
         */
        var setupQuad = function(gl, options) {
            var positionLocation = options.positionLocation || 0;
            var scale = options.scale || 1;

            var objects = [];

            var vertexObject = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexObject);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                1.0 * scale, 1.0 * scale, -1.0 * scale, 1.0 * scale, -1.0 * scale, -1.0 * scale,
                1.0 * scale, 1.0 * scale, -1.0 * scale, -1.0 * scale,
                1.0 * scale, -1.0 * scale,
            ]), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            objects.push(vertexObject);

            if (options.texcoordLocation !== undefined) {
                var llx = options.lowerLeftTexCoords[0];
                var lly = options.lowerLeftTexCoords[1];
                var urx = options.upperRightTexCoords[0];
                var ury = options.upperRightTexCoords[1];

                var vertexObject = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexObject);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    urx, ury,
                    llx, ury,
                    llx, lly,
                    urx, ury,
                    llx, lly,
                    urx, lly
                ]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(options.texcoordLocation);
                gl.vertexAttribPointer(options.texcoordLocation, 2, gl.FLOAT, false, 0, 0);
                objects.push(vertexObject);
            }

            return objects;
        };

        /**
         * Creates a program and buffers for rendering a textured quad.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {number} opt_positionLocation The attrib location for
         *        position. Default = 0.
         * @param {number} opt_texcoordLocation The attrib location for
         *        texture coords. Default = 1.
         * @return {!WebGLProgram}
         */
        var setupTexturedQuad = function(
            gl, opt_positionLocation, opt_texcoordLocation) {
            var program = setupSimpleTextureProgram(
                gl, opt_positionLocation, opt_texcoordLocation);
            setupUnitQuad(gl, opt_positionLocation, opt_texcoordLocation);
            return program;
        };

        /**
         * Creates a program and buffers for rendering a color quad.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {number} opt_positionLocation The attrib location for position.
         * @return {!WebGLProgram}
         */
        var setupColorQuad = function(gl, opt_positionLocation) {
            opt_positionLocation = opt_positionLocation || 0;
            var program = setupSimpleColorProgram(gl);
            setupUnitQuad(gl, opt_positionLocation);
            return program;
        };

        /**
         * Creates a program and buffers for rendering a textured quad with
         * specified lower left and upper right texture coordinates.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {!Array.<number>} lowerLeftTexCoords The texture coordinates for the lower left corner.
         * @param {!Array.<number>} upperRightTexCoords The texture coordinates for the upper right corner.
         * @param {number} opt_positionLocation The attrib location for position.
         * @param {number} opt_texcoordLocation The attrib location for texture coords.
         * @return {!WebGLProgram}
         */
        var setupTexturedQuadWithTexCoords = function(
            gl, lowerLeftTexCoords, upperRightTexCoords,
            opt_positionLocation, opt_texcoordLocation) {
            var program = setupSimpleTextureProgram(
                gl, opt_positionLocation, opt_texcoordLocation);
            setupUnitQuadWithTexCoords(gl, lowerLeftTexCoords, upperRightTexCoords,
                opt_positionLocation, opt_texcoordLocation);
            return program;
        };

        /**
         * Creates a unit quad with only positions of a given resolution.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {number} gridRes The resolution of the mesh grid,
         *     expressed in the number of quads across and down.
         * @param {number} opt_positionLocation The attrib location for position.
         */
        var setupIndexedQuad = function(
            gl, gridRes, opt_positionLocation, opt_flipOddTriangles) {
            return setupIndexedQuadWithOptions(gl, {
                gridRes: gridRes,
                positionLocation: opt_positionLocation,
                flipOddTriangles: opt_flipOddTriangles
            });
        };

        /**
         * Creates a quad with various options.
         * @param {!WebGLRenderingContext} gl The WebGLRenderingContext to use.
         * @param {!Object) options The options. See below.
         * @return {!Array.<WebGLBuffer>} The created buffers.
         *     [positions, <colors>, indices]
         *
         * Options:
         *   gridRes: number of quads across and down grid.
         *   positionLocation: attrib location for position
         *   flipOddTriangles: reverse order of vertices of every other
         *       triangle
         *   positionOffset: offset added to each vertex
         *   positionMult: multipier for each vertex
         *   colorLocation: attrib location for vertex colors. If
         *      undefined no vertex colors will be created.
         */
        var setupIndexedQuadWithOptions = function(gl, options) {
            var positionLocation = options.positionLocation || 0;
            var objects = [];

            var gridRes = options.gridRes || 1;
            var positionOffset = options.positionOffset || 0;
            var positionMult = options.positionMult || 1;
            var vertsAcross = gridRes + 1;
            var numVerts = vertsAcross * vertsAcross;
            var positions = new Float32Array(numVerts * 3);
            var indices = new Uint16Array(6 * gridRes * gridRes);
            var poffset = 0;

            for (var yy = 0; yy <= gridRes; ++yy) {
                for (var xx = 0; xx <= gridRes; ++xx) {
                    positions[poffset + 0] = (-1 + 2 * xx / gridRes) * positionMult + positionOffset;
                    positions[poffset + 1] = (-1 + 2 * yy / gridRes) * positionMult + positionOffset;
                    positions[poffset + 2] = 0;

                    poffset += 3;
                }
            }

            var buf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
            objects.push(buf);

            if (options.colorLocation !== undefined) {
                var colors = new Float32Array(numVerts * 4);
                for (var yy = 0; yy <= gridRes; ++yy) {
                    for (var xx = 0; xx <= gridRes; ++xx) {
                        if (options.color !== undefined) {
                            colors[poffset + 0] = options.color[0];
                            colors[poffset + 1] = options.color[1];
                            colors[poffset + 2] = options.color[2];
                            colors[poffset + 3] = options.color[3];
                        } else {
                            colors[poffset + 0] = xx / gridRes;
                            colors[poffset + 1] = yy / gridRes;
                            colors[poffset + 2] = (xx / gridRes) * (yy / gridRes);
                            colors[poffset + 3] = (yy % 2) * 0.5 + 0.5;
                        }
                        poffset += 4;
                    }
                }

                var buf = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(options.colorLocation);
                gl.vertexAttribPointer(options.colorLocation, 4, gl.FLOAT, false, 0, 0);
                objects.push(buf);
            }

            var tbase = 0;
            for (var yy = 0; yy < gridRes; ++yy) {
                var index = yy * vertsAcross;
                for (var xx = 0; xx < gridRes; ++xx) {
                    indices[tbase + 0] = index + 0;
                    indices[tbase + 1] = index + 1;
                    indices[tbase + 2] = index + vertsAcross;
                    indices[tbase + 3] = index + vertsAcross;
                    indices[tbase + 4] = index + 1;
                    indices[tbase + 5] = index + vertsAcross + 1;

                    if (options.flipOddTriangles) {
                        indices[tbase + 4] = index + vertsAcross + 1;
                        indices[tbase + 5] = index + 1;
                    }

                    index += 1;
                    tbase += 6;
                }
            }

            var buf = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            objects.push(buf);

            return objects;
        };

        /**
         * Fills the given texture with a solid color
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!WebGLTexture} tex The texture to fill.
         * @param {number} width The width of the texture to create.
         * @param {number} height The height of the texture to create.
         * @param {!Array.<number>} color The color to fill with. A 4 element array
         *        where each element is in the range 0 to 255.
         * @param {number} opt_level The level of the texture to fill. Default = 0.
         */
        var fillTexture = function(gl, tex, width, height, color, opt_level) {
            opt_level = opt_level || 0;
            var numPixels = width * height;
            var size = numPixels * 4;
            var buf = new Uint8Array(size);
            for (var ii = 0; ii < numPixels; ++ii) {
                var off = ii * 4;
                buf[off + 0] = color[0];
                buf[off + 1] = color[1];
                buf[off + 2] = color[2];
                buf[off + 3] = color[3];
            }
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(
                gl.TEXTURE_2D, opt_level, gl.RGBA, width, height, 0,
                gl.RGBA, gl.UNSIGNED_BYTE, buf);
        };

        /**
         * Creates a textures and fills it with a solid color
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} width The width of the texture to create.
         * @param {number} height The height of the texture to create.
         * @param {!Array.<number>} color The color to fill with. A 4 element array
         *        where each element is in the range 0 to 255.
         * @return {!WebGLTexture}
         */
        var createColoredTexture = function(gl, width, height, color) {
            var tex = gl.createTexture();
            fillTexture(gl, tex, width, height, color);
            return tex;
        };

        var ubyteToFloat = function(c) {
            return c / 255;
        };

        var ubyteColorToFloatColor = function(color) {
            var floatColor = [];
            for (var ii = 0; ii < color.length; ++ii) {
                floatColor[ii] = ubyteToFloat(color[ii]);
            }
            return floatColor;
        };

        /**
         * Sets the "u_color" uniform of the current program to color.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!Array.<number> color 4 element array of 0-1 color
         *      components.
         */
        var setFloatDrawColor = function(gl, color) {
            var program = gl.getParameter(gl.CURRENT_PROGRAM);
            var colorLocation = gl.getUniformLocation(program, "u_color");
            gl.uniform4fv(colorLocation, color);
        };

        /**
         * Sets the "u_color" uniform of the current program to color.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!Array.<number> color 4 element array of 0-255 color
         *      components.
         */
        var setUByteDrawColor = function(gl, color) {
            setFloatDrawColor(gl, ubyteColorToFloatColor(color));
        };

        /**
         * Draws a previously setup quad in the given color.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!Array.<number>} color The color to draw with. A 4
         *        element array where each element is in the range 0 to
         *        1.
         */
        var drawFloatColorQuad = function(gl, color) {
            var program = gl.getParameter(gl.CURRENT_PROGRAM);
            var colorLocation = gl.getUniformLocation(program, "u_color");
            gl.uniform4fv(colorLocation, color);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        };


        /**
         * Draws a previously setup quad in the given color.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!Array.<number>} color The color to draw with. A 4
         *        element array where each element is in the range 0 to
         *        255.
         */
        var drawUByteColorQuad = function(gl, color) {
            drawFloatColorQuad(gl, ubyteColorToFloatColor(color));
        };

        /**
         * Draws a previously setupUnitQuad.
         * @param {!WebGLContext} gl The WebGLContext to use.
         */
        var drawUnitQuad = function(gl) {
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        };

        /**
         * Clears then Draws a previously setupUnitQuad.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!Array.<number>} opt_color The color to fill clear with before
         *        drawing. A 4 element array where each element is in the range 0 to
         *        255. Default [255, 255, 255, 255]
         */
        var clearAndDrawUnitQuad = function(gl, opt_color) {
            opt_color = opt_color || [255, 255, 255, 255];
            gl.clearColor(
                opt_color[0] / 255,
                opt_color[1] / 255,
                opt_color[2] / 255,
                opt_color[3] / 255);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            drawUnitQuad(gl);
        };

        /**
         * Draws a quad previsouly settup with setupIndexedQuad.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} gridRes Resolution of grid.
         */
        var drawIndexedQuad = function(gl, gridRes) {
            gl.drawElements(gl.TRIANGLES, gridRes * gridRes * 6, gl.UNSIGNED_SHORT, 0);
        };

        /**
         * Draws a previously setupIndexedQuad
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} gridRes Resolution of grid.
         * @param {!Array.<number>} opt_color The color to fill clear with before
         *        drawing. A 4 element array where each element is in the range 0 to
         *        255. Default [255, 255, 255, 255]
         */
        var clearAndDrawIndexedQuad = function(gl, gridRes, opt_color) {
            opt_color = opt_color || [255, 255, 255, 255];
            gl.clearColor(
                opt_color[0] / 255,
                opt_color[1] / 255,
                opt_color[2] / 255,
                opt_color[3] / 255);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            drawIndexedQuad(gl, gridRes);
        };

        /**
         * Checks that a portion of a canvas is 1 color.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} x left corner of region to check.
         * @param {number} y bottom corner of region to check.
         * @param {number} width width of region to check.
         * @param {number} height width of region to check.
         * @param {!Array.<number>} color The color to fill clear with before drawing. A
         *        4 element array where each element is in the range 0 to 255.
         * @param {number} opt_errorRange Optional. Acceptable error in
         *        color checking. 0 by default.
         * @param {!function()} sameFn Function to call if all pixels
         *        are the same as color.
         * @param {!function()} differentFn Function to call if a pixel
         *        is different than color
         * @param {!function()} logFn Function to call for logging.
         */
        var checkCanvasRectColor = function(gl, x, y, width, height, color, opt_errorRange, sameFn, differentFn, logFn) {
            var errorRange = opt_errorRange || 0;
            if (!errorRange.length) {
                errorRange = [errorRange, errorRange, errorRange, errorRange]
            }
            var buf;
            if (gl instanceof WebGLRenderingContext) {
                buf = new Uint8Array(width * height * 4);
                gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, buf);
            } else {
                buf = gl.getImageData(x, y, width, height).data;
            }
            for (var i = 0; i < width * height; ++i) {
                var offset = i * 4;
                for (var j = 0; j < color.length; ++j) {
                    if (Math.abs(buf[offset + j] - color[j]) > errorRange[j]) {
                        differentFn();
                        var was = buf[offset + 0].toString();
                        for (j = 1; j < color.length; ++j) {
                            was += "," + buf[offset + j];
                        }
                        logFn('at (' + (x + (i % width)) + ', ' + (y + Math.floor(i / width)) +
                            ') expected: ' + color + ' was ' + was);
                        return;
                    }
                }
            }
            sameFn();
        };

        /**
         * Checks that a portion of a canvas is 1 color.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} x left corner of region to check.
         * @param {number} y bottom corner of region to check.
         * @param {number} width width of region to check.
         * @param {number} height width of region to check.
         * @param {!Array.<number>} color The color to fill clear with before drawing. A
         *        4 element array where each element is in the range 0 to 255.
         * @param {string} opt_msg Message to associate with success. Eg
         *        ("should be red").
         * @param {number} opt_errorRange Optional. Acceptable error in
         *        color checking. 0 by default.
         */
        var checkCanvasRect = function(gl, x, y, width, height, color, opt_msg, opt_errorRange) {
            var msg = opt_msg;
            if (msg === undefined) {
                msg = "should be " + color.toString();
            }
            checkCanvasRectColor(
                gl, x, y, width, height, color, opt_errorRange,
                function() {
                    testPassed(msg);
                },
                function() {
                    testFailed(msg);
                },
                debug);
        };

        /**
         * Checks a rectangular area both inside the area and outside
         * the area.
         * @param {!WebGLRenderingContext|CanvasRenderingContext2D} gl The
         *         WebGLRenderingContext or 2D context to use.
         * @param {number} x left corner of region to check.
         * @param {number} y bottom corner of region to check in case of checking from
         *        a GL context or top corner in case of checking from a 2D context.
         * @param {number} width width of region to check.
         * @param {number} height width of region to check.
         * @param {!Array.<number>} innerColor The color expected inside
         *     the area. A 4 element array where each element is in the
         *     range 0 to 255.
         * @param {!Array.<number>} outerColor The color expected
         *     outside. A 4 element array where each element is in the
         *     range 0 to 255.
         * @param {!number} opt_edgeSize: The number of pixels to skip
         *     around the edges of the area. Defaut 0.
         * @param {!{width:number, height:number}} opt_outerDimensions
         *     The outer dimensions. Default the size of gl.canvas.
         */
        var checkAreaInAndOut = function(gl, x, y, width, height, innerColor, outerColor, opt_edgeSize, opt_outerDimensions) {
            var outerDimensions = opt_outerDimensions || {
                width: gl.canvas.width,
                height: gl.canvas.height
            };
            var edgeSize = opt_edgeSize || 0;
            checkCanvasRect(gl, x + edgeSize, y + edgeSize, width - edgeSize * 2, height - edgeSize * 2, innerColor);
            checkCanvasRect(gl, 0, 0, x - edgeSize, outerDimensions.height, outerColor);
            checkCanvasRect(gl, x + width + edgeSize, 0, outerDimensions.width - x - width - edgeSize, outerDimensions.height, outerColor);
            checkCanvasRect(gl, 0, 0, outerDimensions.width, y - edgeSize, outerColor);
            checkCanvasRect(gl, 0, y + height + edgeSize, outerDimensions.width, outerDimensions.height - y - height - edgeSize, outerColor);
        };


        /**
         * Checks that an entire canvas is 1 color.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!Array.<number>} color The color to fill clear with before drawing. A
         *        4 element array where each element is in the range 0 to 255.
         * @param {string} msg Message to associate with success. Eg ("should be red").
         * @param {number} errorRange Optional. Acceptable error in
         *        color checking. 0 by default.
         */
        var checkCanvas = function(gl, color, msg, errorRange) {
            checkCanvasRect(gl, 0, 0, gl.canvas.width, gl.canvas.height, color, msg, errorRange);
        };

        /**
         * Loads a texture, calls callback when finished.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} url URL of image to load
         * @param {function(!Image): void} callback Function that gets called after
         *        image has loaded
         * @return {!WebGLTexture} The created texture.
         */
        var loadTexture = function(gl, url, callback) {
            var texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            var image = new Image();
            image.onload = function() {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                callback(image);
            };
            image.src = url;
            return texture;
        };

        /**
         * Makes a shallow copy of an object.
         * @param {!Object) src Object to copy
         * @return {!Object} The copy of src.
         */
        var shallowCopyObject = function(src) {
            var dst = {};
            for (var attr in src) {
                if (src.hasOwnProperty(attr)) {
                    dst[attr] = src[attr];
                }
            }
            return dst;
        };

        /**
         * Checks if an attribute exists on an object case insensitive.
         * @param {!Object) obj Object to check
         * @param {string} attr Name of attribute to look for.
         * @return {string?} The name of the attribute if it exists,
         *         undefined if not.
         */
        var hasAttributeCaseInsensitive = function(obj, attr) {
            var lower = attr.toLowerCase();
            for (var key in obj) {
                if (obj.hasOwnProperty(key) && key.toLowerCase() == lower) {
                    return key;
                }
            }
        };

        /**
         * Returns a map of URL querystring options
         * @return {Object?} Object containing all the values in the URL querystring
         */
        var getUrlOptions = function() {
            return {}
        };

        /**
         * Creates a webgl context.
         * @param {!Canvas|string} opt_canvas The canvas tag to get
         *     context from. If one is not passed in one will be
         *     created. If it's a string it's assumed to be the id of a
         *     canvas.
         * @return {!WebGLContext} The created context.
         */
        var create3DContext = function(opt_canvas, opt_attributes) {
            var width = 500
            var height = 500
            if (opt_canvas) {
                if (typeof opt_canvas === 'string') {
                    var canvasList = ENVIRONMENT.canvasList
                    for (var i = 0; i < canvasList.length; ++i) {
                        if (canvasList[i].id === opt_canvas) {
                            width = canvasList[i].width || 500
                            height = canvasList[i].height || 500
                            var ctx = ENVIRONMENT.createContext(width, height, opt_attributes)
                            ctx.canvas = canvasList[i]
                            ctx.canvas._gl = ctx
                            canvas = ctx.canvas
                            return ctx
                        }
                    }
                } else {
                    width = opt_canvas.width || 512
                    height = opt_canvas.height || 512
                    var ctx = ENVIRONMENT.createContext(width, height, opt_attributes)
                    ctx.canvas = opt_canvas
                    ctx.canvas._gl = ctx
                    canvas = ctx.canvas
                    return ctx
                }
            }
            var ctx = ENVIRONMENT.createContext(width, height, opt_attributes)
            canvas = document.createElement("canvas")
            ctx.canvas = canvas
            ctx.canvas._gl = ctx
            return ctx
        }

        /**
         * Gets a GLError value as a string.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} err The webgl error as retrieved from gl.getError().
         * @return {string} the error as a string.
         */
        var getGLErrorAsString = function(gl, err) {
            if (err === gl.NO_ERROR) {
                return "NO_ERROR";
            }
            for (var name in gl) {
                if (gl[name] === err) {
                    return name;
                }
            }
            return err.toString();
        };

        /**
         * Wraps a WebGL function with a function that throws an exception if there is
         * an error.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} fname Name of function to wrap.
         * @return {function} The wrapped function.
         */
        var createGLErrorWrapper = function(context, fname) {
            return function() {
                var rv = context[fname].apply(context, arguments);
                var err = context.getError();
                if (err != context.NO_ERROR)
                    throw "GL error " + getGLErrorAsString(context, err) + " in " + fname;
                return rv;
            };
        };

        /**
         * Creates a WebGL context where all functions are wrapped to throw an exception
         * if there is an error.
         * @param {!Canvas} canvas The HTML canvas to get a context from.
         * @return {!Object} The wrapped context.
         */
        function create3DContextWithWrapperThatThrowsOnGLError(canvas) {
            var context = create3DContext(canvas);
            var wrap = {};
            for (var i in context) {
                try {
                    if (typeof context[i] == 'function') {
                        wrap[i] = createGLErrorWrapper(context, i);
                    } else {
                        wrap[i] = context[i];
                    }
                } catch (e) {
                    error("createContextWrapperThatThrowsOnGLError: Error accessing " + i);
                }
            }
            wrap.getError = function() {
                return context.getError();
            };
            return wrap;
        };

        /**
         * Tests that an evaluated expression generates a specific GL error.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} glError The expected gl error.
         * @param {string} evalSTr The string to evaluate.
         */
        var shouldGenerateGLError = function(gl, glError, evalStr) {
            var exception;
            try {
                eval(evalStr);
            } catch (e) {
                exception = e;
            }
            if (exception) {
                testFailed(evalStr + " threw exception " + exception);
            } else {
                var err = gl.getError();
                if (err != glError) {
                    testFailed(evalStr + " expected: " + getGLErrorAsString(gl, glError) + ". Was " + getGLErrorAsString(gl, err) + ".");
                } else {
                    testPassed(evalStr + " was expected value: " + getGLErrorAsString(gl, glError) + ".");
                }
            }
        };

        /**
         * Tests that the first error GL returns is the specified error.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {number} glError The expected gl error.
         * @param {string} opt_msg
         */
        var glErrorShouldBe = function(gl, glErrors, opt_msg) {
            if (!glErrors.length) {
                glErrors = [glErrors];
            }
            opt_msg = opt_msg || "";
            var err = gl.getError();
            var ndx = glErrors.indexOf(err);
            var errStrs = [];
            for (var ii = 0; ii < glErrors.length; ++ii) {
                errStrs.push(glEnumToString(gl, glErrors[ii]));
            }
            var expected = errStrs.join(" or ");
            if (ndx < 0) {
                var msg = "getError expected" + ((glErrors.length > 1) ? " one of: " : ": ");
                testFailed(msg + expected + ". Was " + glEnumToString(gl, err) + " : " + opt_msg);
            } else {
                var msg = "getError was " + ((glErrors.length > 1) ? "one of: " : "expected value: ");
                testPassed(msg + expected + " : " + opt_msg);
            }
        };

        /**
         * Links a WebGL program, throws if there are errors.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!WebGLProgram} program The WebGLProgram to link.
         * @param {function(string): void) opt_errorCallback callback for errors.
         */
        var linkProgram = function(gl, program, opt_errorCallback) {
            var errFn = opt_errorCallback || testFailed;
            // Link the program
            gl.linkProgram(program);

            // Check the link status
            var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!linked) {
                // something went wrong with the link
                var error = gl.getProgramInfoLog(program);

                errFn("Error in program linking:" + error);

                gl.deleteProgram(program);
            }
        };

        /**
         * Loads text from an external file. This function is synchronous.
         * @param {string} url The url of the external file.
         * @param {!function(bool, string): void} callback that is sent a bool for
         *     success and the string.
         */
        var loadTextFileAsync = function(url, callback) {
            setTimeout(function() {
                var file = ENVIRONMENT.RESOURCES[path.join(ENVIRONMENT.BASEPATH, url)]
                if (file) {
                    var buf = new Buffer(file, 'base64')
                    callback(true, buf.toString())
                } else {
                    throw new Error('error loading file: ' + url)
                }
            }, 1)
        };

        /**
         * Recursively loads a file as a list. Each line is parsed for a relative
         * path. If the file ends in .txt the contents of that file is inserted in
         * the list.
         *
         * @param {string} url The url of the external file.
         * @param {!function(bool, Array<string>): void} callback that is sent a bool
         *     for success and the array of strings.
         */
        var getFileListAsync = function(url, callback) {
            var files = [];

            var getFileListImpl = function(url, callback) {
                var files = [];
                if (url.substr(url.length - 4) == '.txt') {
                    loadTextFileAsync(url, function() {
                        return function(success, text) {
                            if (!success) {
                                callback(false, '');
                                return;
                            }
                            var lines = text.split('\n');
                            var prefix = '';
                            var lastSlash = url.lastIndexOf('/');
                            if (lastSlash >= 0) {
                                prefix = url.substr(0, lastSlash + 1);
                            }
                            var fail = false;
                            var count = 1;
                            var index = 0;
                            for (var ii = 0; ii < lines.length; ++ii) {
                                var str = lines[ii].replace(/^\s\s*/, '').replace(/\s\s*$/, '');
                                if (str.length > 4 &&
                                    str[0] != '#' &&
                                    str[0] != ";" &&
                                    str.substr(0, 2) != "//") {
                                    var names = str.split(/ +/);
                                    new_url = prefix + str;
                                    if (names.length == 1) {
                                        new_url = prefix + str;
                                        ++count;
                                        getFileListImpl(new_url, function(index) {
                                            return function(success, new_files) {
                                                log("got files: " + new_files.length);
                                                if (success) {
                                                    files[index] = new_files;
                                                }
                                                finish(success);
                                            };
                                        }(index++));
                                    } else {
                                        var s = "";
                                        var p = "";
                                        for (var jj = 0; jj < names.length; ++jj) {
                                            s += p + prefix + names[jj];
                                            p = " ";
                                        }
                                        files[index++] = s;
                                    }
                                }
                            }
                            finish(true);

                            function finish(success) {
                                if (!success) {
                                    fail = true;
                                }
                                --count;
                                log("count: " + count);
                                if (!count) {
                                    callback(!fail, files);
                                }
                            }
                        }
                    }());

                } else {
                    files.push(url);
                    callback(true, files);
                }
            };

            getFileListImpl(url, function(success, files) {
                // flatten
                var flat = [];
                flatten(files);

                function flatten(files) {
                    for (var ii = 0; ii < files.length; ++ii) {
                        var value = files[ii];
                        if (typeof(value) == "string") {
                            flat.push(value);
                        } else {
                            flatten(value);
                        }
                    }
                }
                callback(success, flat);
            });
        };

        /**
         * Gets a file from a file/URL
         * @param {string} file the URL of the file to get.
         * @return {string} The contents of the file.
         */
        var readFile = function(file) {
            var buf = new Buffer(ENVIRONMENT.RESOURCES[path.join('resources', file)], 'base64')
            var text = buf.toString()
            return text.replace(/\r/g, "");
        };

        var readFileList = function(url) {
            var files = [];
            if (url.substr(url.length - 4) == '.txt') {
                var lines = readFile(url).split('\n');
                var prefix = '';
                var lastSlash = url.lastIndexOf('/');
                if (lastSlash >= 0) {
                    prefix = url.substr(0, lastSlash + 1);
                }
                for (var ii = 0; ii < lines.length; ++ii) {
                    var str = lines[ii].replace(/^\s\s*/, '').replace(/\s\s*$/, '');
                    if (str.length > 4 &&
                        str[0] != '#' &&
                        str[0] != ";" &&
                        str.substr(0, 2) != "//") {
                        var names = str.split(/ +/);
                        if (names.length == 1) {
                            new_url = prefix + str;
                            files = files.concat(readFileList(new_url));
                        } else {
                            var s = "";
                            var p = "";
                            for (var jj = 0; jj < names.length; ++jj) {
                                s += p + prefix + names[jj];
                                p = " ";
                            }
                            files.push(s);
                        }
                    }
                }
            } else {
                files.push(url);
            }
            return files;
        };

        /**
         * Loads a shader.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} shaderSource The shader source.
         * @param {number} shaderType The type of shader.
         * @param {function(string): void) opt_errorCallback callback for errors.
         * @return {!WebGLShader} The created shader.
         */
        var loadShader = function(gl, shaderSource, shaderType, opt_errorCallback) {
            var errFn = opt_errorCallback || error;
            // Create the shader object
            var shader = gl.createShader(shaderType);
            if (shader == null) {
                errFn("*** Error: unable to create shader '" + shaderSource + "'");
                return null;
            }

            // Load the shader source
            gl.getError()
            gl.shaderSource(shader, shaderSource);
            var err = gl.getError();
            if (err != gl.NO_ERROR) {
                errFn("*** Error loading shader '" + shader + "':" + glEnumToString(gl, err));
                return null;
            }

            // Compile the shader
            gl.compileShader(shader);

            // Check the compile status
            var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!compiled) {
                // Something went wrong during compilation; get the error
                lastError = gl.getShaderInfoLog(shader);
                errFn("*** Error compiling " + glEnumToString(gl, shaderType) + " '" + shader + "':" + lastError);
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        /**
         * Loads a shader from a URL.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {file} file The URL of the shader source.
         * @param {number} type The type of shader.
         * @param {function(string): void) opt_errorCallback callback for errors.
         * @return {!WebGLShader} The created shader.
         */
        var loadShaderFromFile = function(gl, file, type, opt_errorCallback) {
            var shaderSource = readFile(file);
            return loadShader(gl, shaderSource, type, opt_errorCallback);
        };

        /**
         * Gets the content of script.
         */
        var getScript = function(scriptId) {
            var shaderScript = ENVIRONMENT.scriptList[scriptId];
            if (!shaderScript) {
                throw ("*** Error: unknown script element" + scriptId);
            }
            return shaderScript.text;
        };

        /**
         * Loads a shader from a script tag.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} scriptId The id of the script tag.
         * @param {number} opt_shaderType The type of shader. If not passed in it will
         *     be derived from the type of the script tag.
         * @param {function(string): void) opt_errorCallback callback for errors.
         * @return {!WebGLShader} The created shader.
         */
        var loadShaderFromScript = function(
            gl, scriptId, opt_shaderType, opt_errorCallback) {
            var shaderSource = "";
            var shaderType;
            var shaderScript = ENVIRONMENT.scriptList[scriptId];
            if (!shaderScript) {
                throw ("*** Error: unknown script element " + scriptId);
            }
            shaderSource = shaderScript.text;

            if (!opt_shaderType) {
                if (shaderScript.type == "x-shader/x-vertex") {
                    shaderType = gl.VERTEX_SHADER;
                } else if (shaderScript.type == "x-shader/x-fragment") {
                    shaderType = gl.FRAGMENT_SHADER;
                } else if (shaderType != gl.VERTEX_SHADER && shaderType != gl.FRAGMENT_SHADER) {
                    throw ("*** Error: unknown shader type");
                    return null;
                }
            }

            return loadShader(
                gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType,
                opt_errorCallback);
        };

        var loadStandardProgram = function(gl) {
            var program = gl.createProgram();
            gl.attachShader(program, loadStandardVertexShader(gl));
            gl.attachShader(program, loadStandardFragmentShader(gl));
            gl.bindAttribLocation(program, 0, "a_vertex");
            gl.bindAttribLocation(program, 1, "a_normal");
            linkProgram(gl, program);
            return program;
        };

        /**
         * Loads shaders from files, creates a program, attaches the shaders and links.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} vertexShaderPath The URL of the vertex shader.
         * @param {string} fragmentShaderPath The URL of the fragment shader.
         * @param {function(string): void) opt_errorCallback callback for errors.
         * @return {!WebGLProgram} The created program.
         */
        var loadProgramFromFile = function(
            gl, vertexShaderPath, fragmentShaderPath, opt_errorCallback) {
            var program = gl.createProgram();
            var vs = loadShaderFromFile(
                gl, vertexShaderPath, gl.VERTEX_SHADER, opt_errorCallback);
            var fs = loadShaderFromFile(
                gl, fragmentShaderPath, gl.FRAGMENT_SHADER, opt_errorCallback);
            if (vs && fs) {
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                linkProgram(gl, program, opt_errorCallback);
            }
            if (vs) {
                gl.deleteShader(vs);
            }
            if (fs) {
                gl.deleteShader(fs);
            }
            return program;
        };

        /**
         * Loads shaders from script tags, creates a program, attaches the shaders and
         * links.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} vertexScriptId The id of the script tag that contains the
         *        vertex shader.
         * @param {string} fragmentScriptId The id of the script tag that contains the
         *        fragment shader.
         * @param {function(string): void) opt_errorCallback callback for errors.
         * @return {!WebGLProgram} The created program.
         */
        var loadProgramFromScript = function loadProgramFromScript(
            gl, vertexScriptId, fragmentScriptId, opt_errorCallback) {
            var program = gl.createProgram();
            gl.attachShader(
                program,
                loadShaderFromScript(
                    gl, vertexScriptId, gl.VERTEX_SHADER, opt_errorCallback));
            gl.attachShader(
                program,
                loadShaderFromScript(
                    gl, fragmentScriptId, gl.FRAGMENT_SHADER, opt_errorCallback));
            linkProgram(gl, program, opt_errorCallback);
            return program;
        };

        /**
         * Loads shaders from source, creates a program, attaches the shaders and
         * links.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {!WebGLShader} vertexShader The vertex shader.
         * @param {!WebGLShader} fragmentShader The fragment shader.
         * @param {function(string): void) opt_errorCallback callback for errors.
         * @return {!WebGLProgram} The created program.
         */
        var createProgram = function(gl, vertexShader, fragmentShader, opt_errorCallback) {
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            linkProgram(gl, program, opt_errorCallback);
            return program;
        };

        /**
         * Loads shaders from source, creates a program, attaches the shaders and
         * links.
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} vertexShader The vertex shader source.
         * @param {string} fragmentShader The fragment shader source.
         * @param {function(string): void) opt_errorCallback callback for errors.
         * @return {!WebGLProgram} The created program.
         */
        var loadProgram = function(
            gl, vertexShader, fragmentShader, opt_errorCallback) {
            var program;
            var vs = loadShader(
                gl, vertexShader, gl.VERTEX_SHADER, opt_errorCallback);
            var fs = loadShader(
                gl, fragmentShader, gl.FRAGMENT_SHADER, opt_errorCallback);
            if (vs && fs) {
                program = createProgram(gl, vs, fs, opt_errorCallback)
            }
            if (vs) {
                gl.deleteShader(vs);
            }
            if (fs) {
                gl.deleteShader(fs);
            }
            return program;
        };

        /**
         * Loads shaders from source, creates a program, attaches the shaders and
         * links but expects error.
         *
         * GLSL 1.0.17 10.27 effectively says that compileShader can
         * always succeed as long as linkProgram fails so we can't
         * rely on compileShader failing. This function expects
         * one of the shader to fail OR linking to fail.
         *
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {string} vertexShaderScriptId The vertex shader.
         * @param {string} fragmentShaderScriptId The fragment shader.
         * @return {WebGLProgram} The created program.
         */
        var loadProgramFromScriptExpectError = function(
            gl, vertexShaderScriptId, fragmentShaderScriptId) {
            var vertexShader = loadShaderFromScript(gl, vertexShaderScriptId);
            if (!vertexShader) {
                return null;
            }
            var fragmentShader = loadShaderFromScript(gl, fragmentShaderScriptId);
            if (!fragmentShader) {
                return null;
            }
            var linkSuccess = true;
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            linkSuccess = true;
            linkProgram(gl, program, function() {
                linkSuccess = false;
            });
            return linkSuccess ? program : null;
        };


        var getActiveMap = function(gl, program, typeInfo) {
            var numVariables = gl.getProgramParameter(program, gl[typeInfo.param]);
            var variables = {};
            for (var ii = 0; ii < numVariables; ++ii) {
                var info = gl[typeInfo.activeFn](program, ii);
                variables[info.name] = {
                    name: info.name,
                    size: info.size,
                    type: info.type,
                    location: gl[typeInfo.locFn](program, info.name)
                };
            }
            return variables;
        };

        /**
         * Returns a map of attrib names to info about those
         * attribs
         *
         * eg:
         *    { "attrib1Name":
         *      {
         *        name: "attrib1Name",
         *        size: 1,
         *        type: gl.FLOAT_MAT2,
         *        location: 0
         *      },
         *      "attrib2Name[0]":
         *      {
         *         name: "attrib2Name[0]",
         *         size: 4,
         *         type: gl.FLOAT,
         *         location: 1
         *      },
         *    }
         *
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {WebGLProgram} The program to query for attribs.
         * @return the map.
         */
        var getAttribMap = function(gl, program) {
            return getActiveMap(gl, program, {
                param: "ACTIVE_ATTRIBS",
                activeFn: "getActiveAttrib",
                locFn: "getAttribLocation"
            });
        };

        /**
         * Returns a map of uniform names to info about those uniform
         *
         * eg:
         *    { "uniform1Name":
         *      {
         *        name: "uniform1Name",
         *        size: 1,
         *        type: gl.FLOAT_MAT2,
         *        location: WebGLUniformLocation
         *      },
         *      "uniform2Name[0]":
         *      {
         *         name: "uniform2Name[0]",
         *         size: 4,
         *         type: gl.FLOAT,
         *         location: WebGLUniformLocation
         *      },
         *    }
         *
         * @param {!WebGLContext} gl The WebGLContext to use.
         * @param {WebGLProgram} The program to query for uniforms.
         * @return the map.
         */
        var getUniformMap = function(gl, program) {
            return getActiveMap(gl, program, {
                param: "ACTIVE_UNIFORMS",
                activeFn: "getActiveUniform",
                locFn: "getUniformLocation"
            });
        };

        var basePath;
        var getBasePath = function() {
            return ''
        };

        var loadStandardVertexShader = function(gl) {
            return loadShaderFromFile(
                gl, getBasePath() + "vertexShader.vert", gl.VERTEX_SHADER);
        };

        var loadStandardFragmentShader = function(gl) {
            return loadShaderFromFile(
                gl, getBasePath() + "fragmentShader.frag", gl.FRAGMENT_SHADER);
        };

        /**
         * Loads an image asynchronously.
         * @param {string} url URL of image to load.
         * @param {!function(!Element): void} callback Function to call
         *     with loaded image.
         */
        var loadImageAsync = function(url, callback) {
            throw new Error("Image not supported")
        };

        /**
         * Loads an array of images.
         * @param {!Array.<string>} urls URLs of images to load.
         * @param {!function(!{string, img}): void} callback. Callback
         *     that gets passed map of urls to img tags.
         */
        var loadImagesAsync = function(urls, callback) {
            throw new Error("loadImagesAsync not supported")
        };

        var getUrlArguments = function() {
            return {}
        };

        var makeImage = function(canvas) {
            var imgData = canvas.getContext("2d").getImageData(
                0, 0, canvas.width, canvas.height)
            var img = new Image()
            img._width = imgData.width
            img._height = imgData.height
            img._data = imgData.data
            return img
        };

        var insertImage = function(element, caption, img) {};

        var addShaderSource = function(element, label, source, opt_url) {};

        // Add your prefix here.
        var browserPrefixes = [
            "",
            "MOZ_",
            "OP_",
            "WEBKIT_"
        ];

        /**
         * Given an extension name like WEBGL_compressed_texture_s3tc
         * returns the name of the supported version extension, like
         * WEBKIT_WEBGL_compressed_teture_s3tc
         * @param {string} name Name of extension to look for
         * @return {string} name of extension found or undefined if not
         *     found.
         */
        var getSupportedExtensionWithKnownPrefixes = function(gl, name) {
            var supported = gl.getSupportedExtensions();
            for (var ii = 0; ii < browserPrefixes.length; ++ii) {
                var prefixedName = browserPrefixes[ii] + name;
                if (supported.indexOf(prefixedName) >= 0) {
                    return prefixedName;
                }
            }
        };

        /**
         * Given an extension name like WEBGL_compressed_texture_s3tc
         * returns the supported version extension, like
         * WEBKIT_WEBGL_compressed_teture_s3tc
         * @param {string} name Name of extension to look for
         * @return {WebGLExtension} The extension or undefined if not
         *     found.
         */
        var getExtensionWithKnownPrefixes = function(gl, name) {
            for (var ii = 0; ii < browserPrefixes.length; ++ii) {
                var prefixedName = browserPrefixes[ii] + name;
                var ext = gl.getExtension(prefixedName);
                if (ext) {
                    return ext;
                }
            }
        };


        var replaceRE = /\$\((\w+)\)/g;

        /**
         * Replaces strings with property values.
         * Given a string like "hello $(first) $(last)" and an object
         * like {first:"John", last:"Smith"} will return
         * "hello John Smith".
         * @param {string} str String to do replacements in
         * @param {...} 1 or more objects conaining properties.
         */
        var replaceParams = function(str) {
            var args = arguments;
            return str.replace(replaceRE, function(str, p1, offset, s) {
                for (var ii = 1; ii < args.length; ++ii) {
                    if (args[ii][p1] !== undefined) {
                        return args[ii][p1];
                    }
                }
                throw "unknown string param '" + p1 + "'";
            });
        };


        /**
         * Provides requestAnimationFrame in a cross browser way.
         */
        var requestAnimFrameImpl_;

        var requestAnimFrame = function(callback, element) {
            if (!requestAnimFrameImpl_) {
                requestAnimFrameImpl_ = function() {
                    return function(callback, element) {
                        return setTimeout(callback, 1000 / 70);
                    };
                }();
            }

            return requestAnimFrameImpl_(callback, element);
        };

        /**
         * Provides cancelAnimationFrame in a cross browser way.
         */
        var cancelAnimFrame = (function() {
            return clearTimeout;
        })();

        /**
         * Waits for the browser to composite the canvas associated with
         * the WebGL context passed in.
         */
        var waitForComposite = function(gl, callback) {
            if (typeof gl === 'function') {
                callback = gl;
            }
            var frames = 5;
            var countDown = function() {
                if (frames == 0) {
                    callback();
                } else {
                    --frames;
                    requestAnimFrame(countDown);
                }
            };
            countDown();
        };

        /**
         * Starts playing a video and waits for it to be consumable.
         * @param {!HTMLVideoElement} video An HTML5 Video element.
         * @param {!function(!HTMLVideoElement): void>} callback. Function to call when
         *        video is ready.
         */
        var startPlayingAndWaitForVideo = function(video, callback) {
            var gotPlaying = false;
            var gotTimeUpdate = false;

            var maybeCallCallback = function() {
                if (gotPlaying && gotTimeUpdate && callback) {
                    callback(video);
                    callback = undefined;
                    video.removeEventListener('playing', playingListener, true);
                    video.removeEventListener('timeupdate', timeupdateListener, true);
                }
            };

            var playingListener = function() {
                gotPlaying = true;
                maybeCallCallback();
            };

            var timeupdateListener = function() {
                // Checking to make sure the current time has advanced beyond
                // the start time seems to be a reliable heuristic that the
                // video element has data that can be consumed.
                if (video.currentTime > 0.0) {
                    gotTimeUpdate = true;
                    maybeCallCallback();
                }
            };

            video.addEventListener('playing', playingListener, true);
            video.addEventListener('timeupdate', timeupdateListener, true);
            video.loop = true;
            video.play();
        };

        /**
         * Runs an array of functions, yielding to the browser between each step.
         * If you want to know when all the steps are finished add a last step.
         * @param {!Array.<function(): void>} steps. Array of functions.
         */
        var runSteps = function(steps) {
            if (!steps.length) {
                return;
            }

            // copy steps so they can't be modifed.
            var stepsToRun = steps.slice();
            var currentStep = 0;
            var runNextStep = function() {
                stepsToRun[currentStep++]();
                if (currentStep < stepsToRun.length) {
                    setTimeout(runNextStep, 1);
                }
            };
            runNextStep();
        };


        /**
         * Given an extension name like WEBGL_compressed_texture_s3tc
         * returns the supported version extension, like
         * WEBKIT_WEBGL_compressed_teture_s3tc
         * @param {string} name Name of extension to look for.
         * @return {WebGLExtension} The extension or undefined if not
         *     found.
         */
        var getExtensionWithKnownPrefixes = function(gl, name) {
            for (var ii = 0; ii < browserPrefixes.length; ++ii) {
                var prefixedName = browserPrefixes[ii] + name;
                var ext = gl.getExtension(prefixedName);
                if (ext) {
                    return ext;
                }
            }
        };

        /**
         * Returns possible prefixed versions of an extension's name.
         * @param {string} name Name of extension. May already include a prefix.
         * @return {Array.<string>} Variations of the extension name with known
         *     browser prefixes.
         */
        var getExtensionPrefixedNames = function(name) {
            var unprefix = function(name) {
                for (var ii = 0; ii < browserPrefixes.length; ++ii) {
                    if (browserPrefixes[ii].length > 0 &&
                        name.substring(0, browserPrefixes[ii].length).toLowerCase() ===
                        browserPrefixes[ii].toLowerCase()) {
                        return name.substring(browserPrefixes[ii].length);
                    }
                }
                return name;
            }

            var unprefixed = unprefix(name);

            var variations = [];
            for (var ii = 0; ii < browserPrefixes.length; ++ii) {
                variations.push(browserPrefixes[ii] + unprefixed);
            }

            return variations;
        };

        return {
            addShaderSource: addShaderSource,
            cancelAnimFrame: cancelAnimFrame,
            create3DContext: create3DContext,
            create3DContextWithWrapperThatThrowsOnGLError: create3DContextWithWrapperThatThrowsOnGLError,
            checkCanvas: checkCanvas,
            checkCanvasRect: checkCanvasRect,
            checkCanvasRectColor: checkCanvasRectColor,
            checkAreaInAndOut: checkAreaInAndOut,
            createColoredTexture: createColoredTexture,
            createProgram: createProgram,
            clearAndDrawUnitQuad: clearAndDrawUnitQuad,
            clearAndDrawIndexedQuad: clearAndDrawIndexedQuad,
            drawUnitQuad: drawUnitQuad,
            drawIndexedQuad: drawIndexedQuad,
            drawUByteColorQuad: drawUByteColorQuad,
            drawFloatColorQuad: drawFloatColorQuad,
            endsWith: endsWith,
            fillTexture: fillTexture,
            getExtensionWithKnownPrefixes: getExtensionWithKnownPrefixes,
            getFileListAsync: getFileListAsync,
            getLastError: getLastError,
            getScript: getScript,
            getSupportedExtensionWithKnownPrefixes: getSupportedExtensionWithKnownPrefixes,
            getUrlArguments: getUrlArguments,
            getUrlOptions: getUrlOptions,
            getAttribMap: getAttribMap,
            getUniformMap: getUniformMap,
            glEnumToString: glEnumToString,
            glErrorShouldBe: glErrorShouldBe,
            hasAttributeCaseInsensitive: hasAttributeCaseInsensitive,
            insertImage: insertImage,
            loadImageAsync: loadImageAsync,
            loadImagesAsync: loadImagesAsync,
            loadProgram: loadProgram,
            loadProgramFromFile: loadProgramFromFile,
            loadProgramFromScript: loadProgramFromScript,
            loadProgramFromScriptExpectError: loadProgramFromScriptExpectError,
            loadShader: loadShader,
            loadShaderFromFile: loadShaderFromFile,
            loadShaderFromScript: loadShaderFromScript,
            loadStandardProgram: loadStandardProgram,
            loadStandardVertexShader: loadStandardVertexShader,
            loadStandardFragmentShader: loadStandardFragmentShader,
            loadTextFileAsync: loadTextFileAsync,
            loadTexture: loadTexture,
            log: log,
            loggingOff: loggingOff,
            makeImage: makeImage,
            error: error,
            shallowCopyObject: shallowCopyObject,
            setupColorQuad: setupColorQuad,
            setupProgram: setupProgram,
            setupIndexedQuad: setupIndexedQuad,
            setupIndexedQuadWithOptions: setupIndexedQuadWithOptions,
            setupSimpleColorFragmentShader: setupSimpleColorFragmentShader,
            setupSimpleColorVertexShader: setupSimpleColorVertexShader,
            setupSimpleColorProgram: setupSimpleColorProgram,
            setupSimpleTextureFragmentShader: setupSimpleTextureFragmentShader,
            setupSimpleTextureProgram: setupSimpleTextureProgram,
            setupSimpleTextureVertexShader: setupSimpleTextureVertexShader,
            setupSimpleVertexColorFragmentShader: setupSimpleVertexColorFragmentShader,
            setupSimpleVertexColorProgram: setupSimpleVertexColorProgram,
            setupSimpleVertexColorVertexShader: setupSimpleVertexColorVertexShader,
            setupNoTexCoordTextureProgram: setupNoTexCoordTextureProgram,
            setupNoTexCoordTextureVertexShader: setupNoTexCoordTextureVertexShader,
            setupTexturedQuad: setupTexturedQuad,
            setupTexturedQuadWithTexCoords: setupTexturedQuadWithTexCoords,
            setupUnitQuad: setupUnitQuad,
            setupUnitQuadWithTexCoords: setupUnitQuadWithTexCoords,
            setupQuad: setupQuad,
            setFloatDrawColor: setFloatDrawColor,
            setUByteDrawColor: setUByteDrawColor,
            startPlayingAndWaitForVideo: startPlayingAndWaitForVideo,
            startsWith: startsWith,
            shouldGenerateGLError: shouldGenerateGLError,
            readFile: readFile,
            readFileList: readFileList,
            replaceParams: replaceParams,
            requestAnimFrame: requestAnimFrame,
            waitForComposite: waitForComposite,
            runSteps: runSteps,
            getExtensionPrefixedNames: getExtensionPrefixedNames,

            none: false
        }
    }


    var WebGLTestUtils = createTestUtils();;;
    ENVIRONMENT.postHook = function() {
        ENVIRONMENT.tape.end()
    };


    /******************* BEGIN TEST CASE *******************/




    "use strict";
    description("This test ensures that the WebGL context has all the constants and (non-function) properties in the specification.");

    var constants = {
        /* ClearBufferMask */
        DEPTH_BUFFER_BIT: 0x00000100,
        STENCIL_BUFFER_BIT: 0x00000400,
        COLOR_BUFFER_BIT: 0x00004000,

        /* BeginMode */
        POINTS: 0x0000,
        LINES: 0x0001,
        LINE_LOOP: 0x0002,
        LINE_STRIP: 0x0003,
        TRIANGLES: 0x0004,
        TRIANGLE_STRIP: 0x0005,
        TRIANGLE_FAN: 0x0006,

        /* AlphaFunction (not supported in ES20) */
        /*      NEVER */
        /*      LESS */
        /*      EQUAL */
        /*      LEQUAL */
        /*      GREATER */
        /*      NOTEQUAL */
        /*      GEQUAL */
        /*      ALWAYS */

        /* BlendingFactorDest */
        ZERO: 0,
        ONE: 1,
        SRC_COLOR: 0x0300,
        ONE_MINUS_SRC_COLOR: 0x0301,
        SRC_ALPHA: 0x0302,
        ONE_MINUS_SRC_ALPHA: 0x0303,
        DST_ALPHA: 0x0304,
        ONE_MINUS_DST_ALPHA: 0x0305,

        /* BlendingFactorSrc */
        /*      ZERO */
        /*      ONE */
        DST_COLOR: 0x0306,
        ONE_MINUS_DST_COLOR: 0x0307,
        SRC_ALPHA_SATURATE: 0x0308,
        /*      SRC_ALPHA */
        /*      ONE_MINUS_SRC_ALPHA */
        /*      DST_ALPHA */
        /*      ONE_MINUS_DST_ALPHA */

        /* BlendEquationSeparate */
        FUNC_ADD: 0x8006,
        BLEND_EQUATION: 0x8009,
        BLEND_EQUATION_RGB: 0x8009,
        /* same as BLEND_EQUATION */
        BLEND_EQUATION_ALPHA: 0x883D,

        /* BlendSubtract */
        FUNC_SUBTRACT: 0x800A,
        FUNC_REVERSE_SUBTRACT: 0x800B,

        /* Separate Blend Functions */
        BLEND_DST_RGB: 0x80C8,
        BLEND_SRC_RGB: 0x80C9,
        BLEND_DST_ALPHA: 0x80CA,
        BLEND_SRC_ALPHA: 0x80CB,
        CONSTANT_COLOR: 0x8001,
        ONE_MINUS_CONSTANT_COLOR: 0x8002,
        CONSTANT_ALPHA: 0x8003,
        ONE_MINUS_CONSTANT_ALPHA: 0x8004,
        BLEND_COLOR: 0x8005,

        /* Buffer Objects */
        ARRAY_BUFFER: 0x8892,
        ELEMENT_ARRAY_BUFFER: 0x8893,
        ARRAY_BUFFER_BINDING: 0x8894,
        ELEMENT_ARRAY_BUFFER_BINDING: 0x8895,

        STREAM_DRAW: 0x88E0,
        STATIC_DRAW: 0x88E4,
        DYNAMIC_DRAW: 0x88E8,

        BUFFER_SIZE: 0x8764,
        BUFFER_USAGE: 0x8765,

        CURRENT_VERTEX_ATTRIB: 0x8626,

        /* CullFaceMode */
        FRONT: 0x0404,
        BACK: 0x0405,
        FRONT_AND_BACK: 0x0408,

        /* DepthFunction */
        /*      NEVER */
        /*      LESS */
        /*      EQUAL */
        /*      LEQUAL */
        /*      GREATER */
        /*      NOTEQUAL */
        /*      GEQUAL */
        /*      ALWAYS */

        /* EnableCap */
        /* TEXTURE_2D */
        CULL_FACE: 0x0B44,
        BLEND: 0x0BE2,
        DITHER: 0x0BD0,
        STENCIL_TEST: 0x0B90,
        DEPTH_TEST: 0x0B71,
        SCISSOR_TEST: 0x0C11,
        POLYGON_OFFSET_FILL: 0x8037,
        SAMPLE_ALPHA_TO_COVERAGE: 0x809E,
        SAMPLE_COVERAGE: 0x80A0,

        /* ErrorCode */
        NO_ERROR: 0,
        INVALID_ENUM: 0x0500,
        INVALID_VALUE: 0x0501,
        INVALID_OPERATION: 0x0502,
        OUT_OF_MEMORY: 0x0505,

        /* FrontFaceDirection */
        CW: 0x0900,
        CCW: 0x0901,

        /* GetPName */
        LINE_WIDTH: 0x0B21,
        ALIASED_POINT_SIZE_RANGE: 0x846D,
        ALIASED_LINE_WIDTH_RANGE: 0x846E,
        CULL_FACE_MODE: 0x0B45,
        FRONT_FACE: 0x0B46,
        DEPTH_RANGE: 0x0B70,
        DEPTH_WRITEMASK: 0x0B72,
        DEPTH_CLEAR_VALUE: 0x0B73,
        DEPTH_FUNC: 0x0B74,
        STENCIL_CLEAR_VALUE: 0x0B91,
        STENCIL_FUNC: 0x0B92,
        STENCIL_FAIL: 0x0B94,
        STENCIL_PASS_DEPTH_FAIL: 0x0B95,
        STENCIL_PASS_DEPTH_PASS: 0x0B96,
        STENCIL_REF: 0x0B97,
        STENCIL_VALUE_MASK: 0x0B93,
        STENCIL_WRITEMASK: 0x0B98,
        STENCIL_BACK_FUNC: 0x8800,
        STENCIL_BACK_FAIL: 0x8801,
        STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,
        STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,
        STENCIL_BACK_REF: 0x8CA3,
        STENCIL_BACK_VALUE_MASK: 0x8CA4,
        STENCIL_BACK_WRITEMASK: 0x8CA5,
        VIEWPORT: 0x0BA2,
        SCISSOR_BOX: 0x0C10,
        /*      SCISSOR_TEST */
        COLOR_CLEAR_VALUE: 0x0C22,
        COLOR_WRITEMASK: 0x0C23,
        UNPACK_ALIGNMENT: 0x0CF5,
        PACK_ALIGNMENT: 0x0D05,
        MAX_TEXTURE_SIZE: 0x0D33,
        MAX_VIEWPORT_DIMS: 0x0D3A,
        SUBPIXEL_BITS: 0x0D50,
        RED_BITS: 0x0D52,
        GREEN_BITS: 0x0D53,
        BLUE_BITS: 0x0D54,
        ALPHA_BITS: 0x0D55,
        DEPTH_BITS: 0x0D56,
        STENCIL_BITS: 0x0D57,
        POLYGON_OFFSET_UNITS: 0x2A00,
        /*      POLYGON_OFFSET_FILL */
        POLYGON_OFFSET_FACTOR: 0x8038,
        TEXTURE_BINDING_2D: 0x8069,
        SAMPLE_BUFFERS: 0x80A8,
        SAMPLES: 0x80A9,
        SAMPLE_COVERAGE_VALUE: 0x80AA,
        SAMPLE_COVERAGE_INVERT: 0x80AB,

        /* GetTextureParameter */
        /*      TEXTURE_MAG_FILTER */
        /*      TEXTURE_MIN_FILTER */
        /*      TEXTURE_WRAP_S */
        /*      TEXTURE_WRAP_T */

        COMPRESSED_TEXTURE_FORMATS: 0x86A3,

        /* HintMode */
        DONT_CARE: 0x1100,
        FASTEST: 0x1101,
        NICEST: 0x1102,

        /* HintTarget */
        GENERATE_MIPMAP_HINT: 0x8192,

        /* DataType */
        BYTE: 0x1400,
        UNSIGNED_BYTE: 0x1401,
        SHORT: 0x1402,
        UNSIGNED_SHORT: 0x1403,
        INT: 0x1404,
        UNSIGNED_INT: 0x1405,
        FLOAT: 0x1406,

        /* PixelFormat */
        DEPTH_COMPONENT: 0x1902,
        ALPHA: 0x1906,
        RGB: 0x1907,
        RGBA: 0x1908,
        LUMINANCE: 0x1909,
        LUMINANCE_ALPHA: 0x190A,

        /* PixelType */
        /*      UNSIGNED_BYTE */
        UNSIGNED_SHORT_4_4_4_4: 0x8033,
        UNSIGNED_SHORT_5_5_5_1: 0x8034,
        UNSIGNED_SHORT_5_6_5: 0x8363,

        /* Shaders */
        FRAGMENT_SHADER: 0x8B30,
        VERTEX_SHADER: 0x8B31,
        MAX_VERTEX_ATTRIBS: 0x8869,
        MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB,
        MAX_VARYING_VECTORS: 0x8DFC,
        MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D,
        MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C,
        MAX_TEXTURE_IMAGE_UNITS: 0x8872,
        MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD,
        SHADER_TYPE: 0x8B4F,
        DELETE_STATUS: 0x8B80,
        LINK_STATUS: 0x8B82,
        VALIDATE_STATUS: 0x8B83,
        ATTACHED_SHADERS: 0x8B85,
        ACTIVE_UNIFORMS: 0x8B86,
        ACTIVE_ATTRIBUTES: 0x8B89,
        SHADING_LANGUAGE_VERSION: 0x8B8C,
        CURRENT_PROGRAM: 0x8B8D,

        /* StencilFunction */
        NEVER: 0x0200,
        LESS: 0x0201,
        EQUAL: 0x0202,
        LEQUAL: 0x0203,
        GREATER: 0x0204,
        NOTEQUAL: 0x0205,
        GEQUAL: 0x0206,
        ALWAYS: 0x0207,

        /* StencilOp */
        /*      ZERO */
        KEEP: 0x1E00,
        REPLACE: 0x1E01,
        INCR: 0x1E02,
        DECR: 0x1E03,
        INVERT: 0x150A,
        INCR_WRAP: 0x8507,
        DECR_WRAP: 0x8508,

        /* StringName */
        VENDOR: 0x1F00,
        RENDERER: 0x1F01,
        VERSION: 0x1F02,

        /* TextureMagFilter */
        NEAREST: 0x2600,
        LINEAR: 0x2601,

        /* TextureMinFilter */
        /*      NEAREST */
        /*      LINEAR */
        NEAREST_MIPMAP_NEAREST: 0x2700,
        LINEAR_MIPMAP_NEAREST: 0x2701,
        NEAREST_MIPMAP_LINEAR: 0x2702,
        LINEAR_MIPMAP_LINEAR: 0x2703,

        /* TextureParameterName */
        TEXTURE_MAG_FILTER: 0x2800,
        TEXTURE_MIN_FILTER: 0x2801,
        TEXTURE_WRAP_S: 0x2802,
        TEXTURE_WRAP_T: 0x2803,

        /* TextureTarget */
        TEXTURE_2D: 0x0DE1,
        TEXTURE: 0x1702,

        TEXTURE_CUBE_MAP: 0x8513,
        TEXTURE_BINDING_CUBE_MAP: 0x8514,
        TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,
        TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,
        TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,
        TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,
        TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,
        TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A,
        MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C,

        /* TextureUnit */
        TEXTURE0: 0x84C0,
        TEXTURE1: 0x84C1,
        TEXTURE2: 0x84C2,
        TEXTURE3: 0x84C3,
        TEXTURE4: 0x84C4,
        TEXTURE5: 0x84C5,
        TEXTURE6: 0x84C6,
        TEXTURE7: 0x84C7,
        TEXTURE8: 0x84C8,
        TEXTURE9: 0x84C9,
        TEXTURE10: 0x84CA,
        TEXTURE11: 0x84CB,
        TEXTURE12: 0x84CC,
        TEXTURE13: 0x84CD,
        TEXTURE14: 0x84CE,
        TEXTURE15: 0x84CF,
        TEXTURE16: 0x84D0,
        TEXTURE17: 0x84D1,
        TEXTURE18: 0x84D2,
        TEXTURE19: 0x84D3,
        TEXTURE20: 0x84D4,
        TEXTURE21: 0x84D5,
        TEXTURE22: 0x84D6,
        TEXTURE23: 0x84D7,
        TEXTURE24: 0x84D8,
        TEXTURE25: 0x84D9,
        TEXTURE26: 0x84DA,
        TEXTURE27: 0x84DB,
        TEXTURE28: 0x84DC,
        TEXTURE29: 0x84DD,
        TEXTURE30: 0x84DE,
        TEXTURE31: 0x84DF,
        ACTIVE_TEXTURE: 0x84E0,

        /* TextureWrapMode */
        REPEAT: 0x2901,
        CLAMP_TO_EDGE: 0x812F,
        MIRRORED_REPEAT: 0x8370,

        /* Uniform Types */
        FLOAT_VEC2: 0x8B50,
        FLOAT_VEC3: 0x8B51,
        FLOAT_VEC4: 0x8B52,
        INT_VEC2: 0x8B53,
        INT_VEC3: 0x8B54,
        INT_VEC4: 0x8B55,
        BOOL: 0x8B56,
        BOOL_VEC2: 0x8B57,
        BOOL_VEC3: 0x8B58,
        BOOL_VEC4: 0x8B59,
        FLOAT_MAT2: 0x8B5A,
        FLOAT_MAT3: 0x8B5B,
        FLOAT_MAT4: 0x8B5C,
        SAMPLER_2D: 0x8B5E,
        SAMPLER_CUBE: 0x8B60,

        /* Vertex Arrays */
        VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,
        VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,
        VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,
        VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,
        VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A,
        VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,
        VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F,

        /* Read Format */
        IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A,
        IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B,

        /* Shader Source */
        COMPILE_STATUS: 0x8B81,

        /* Shader Precision-Specified Types */
        LOW_FLOAT: 0x8DF0,
        MEDIUM_FLOAT: 0x8DF1,
        HIGH_FLOAT: 0x8DF2,
        LOW_INT: 0x8DF3,
        MEDIUM_INT: 0x8DF4,
        HIGH_INT: 0x8DF5,

        /* Framebuffer Object. */
        FRAMEBUFFER: 0x8D40,
        RENDERBUFFER: 0x8D41,

        RGBA4: 0x8056,
        RGB5_A1: 0x8057,
        RGB565: 0x8D62,
        DEPTH_COMPONENT16: 0x81A5,
        STENCIL_INDEX: 0x1901,
        STENCIL_INDEX8: 0x8D48,
        DEPTH_STENCIL: 0x84F9,

        RENDERBUFFER_WIDTH: 0x8D42,
        RENDERBUFFER_HEIGHT: 0x8D43,
        RENDERBUFFER_INTERNAL_FORMAT: 0x8D44,
        RENDERBUFFER_RED_SIZE: 0x8D50,
        RENDERBUFFER_GREEN_SIZE: 0x8D51,
        RENDERBUFFER_BLUE_SIZE: 0x8D52,
        RENDERBUFFER_ALPHA_SIZE: 0x8D53,
        RENDERBUFFER_DEPTH_SIZE: 0x8D54,
        RENDERBUFFER_STENCIL_SIZE: 0x8D55,

        FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0,
        FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1,
        FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2,
        FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3,

        COLOR_ATTACHMENT0: 0x8CE0,
        DEPTH_ATTACHMENT: 0x8D00,
        STENCIL_ATTACHMENT: 0x8D20,
        DEPTH_STENCIL_ATTACHMENT: 0x821A,

        NONE: 0,

        FRAMEBUFFER_COMPLETE: 0x8CD5,
        FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6,
        FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7,
        FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9,
        FRAMEBUFFER_UNSUPPORTED: 0x8CDD,

        FRAMEBUFFER_BINDING: 0x8CA6,
        RENDERBUFFER_BINDING: 0x8CA7,
        MAX_RENDERBUFFER_SIZE: 0x84E8,

        INVALID_FRAMEBUFFER_OPERATION: 0x0506,

        /* WebGL-specific enums */
        UNPACK_FLIP_Y_WEBGL: 0x9240,
        UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,
        CONTEXT_LOST_WEBGL: 0x9242,
        UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243,
        BROWSER_DEFAULT_WEBGL: 0x9244
    };

    // Other non-function properties on the WebGL object
    var otherProperties = {
        drawingBufferWidth: "number",
        drawingBufferHeight: "number",
        canvas: "implementation-dependent"
    };

    // Properties to be ignored (as a list of strings) because they were
    // added in versions of the spec that are backward-compatible with
    // this version
    var ignoredProperties = [];

    // Constants removed from the WebGL spec compared to ES 2.0
    var removedConstants = {
        NUM_COMPRESSED_TEXTURE_FORMATS: 0x86A2,
        FIXED: 0x140C,
        ACTIVE_UNIFORM_MAX_LENGTH: 0x8B87,
        ACTIVE_ATTRIBUTE_MAX_LENGTH: 0x8B8A,
        EXTENSIONS: 0x1F03,
        INFO_LOG_LENGTH: 0x8B84,
        SHADER_SOURCE_LENGTH: 0x8B88,
        SHADER_COMPILER: 0x8DFA,
        SHADER_BINARY_FORMATS: 0x8DF8,
        NUM_SHADER_BINARY_FORMATS: 0x8DF9,
    };

    function assertProperty(v, p) {
        if (p in v) {
            return true;
        } else {
            testFailed("Property does not exist: " + p)
            return false;
        }
    }

    function assertNoProperty(v, p) {
        if (p in v) {
            testFailed("Property is defined and should not be: " + p)
            return false;
        } else {
            return true;
        }
    }

    function assertMsg_(bool, msg) {
        if (!bool) // show only failures to avoid spamming result list
            assertMsg(bool, msg);
        return bool;
    }

    debug("");
    debug("Canvas.getContext");

    var canvas = document.getElementById("canvas");
    var wtu = WebGLTestUtils;
    var gl = wtu.create3DContext(canvas);
    var passed = true;
    for (var i in constants) {
        var r = assertProperty(gl, i) && assertMsg_(gl[i] == constants[i], "Property " + i + " value test " + gl[i] + " == " + constants[i]);
        passed = passed && r;
    }
    if (passed) {
        testPassed("All WebGL constants found to have correct values.");
    }
    passed = true;
    for (var i in removedConstants) {
        var r = assertNoProperty(gl, i);
        passed = passed && r;
    }
    if (passed) {
        testPassed("All constants removed from WebGL spec were absent from WebGL context.");
    }
    var extended = false;
    for (var i in gl) {
        if (constants[i] !== undefined) {
            // OK; known constant
        } else if (ignoredProperties.indexOf(i) != -1) {
            // OK; constant that should be ignored because it was added in a later version of the spec
        } else if (otherProperties[i] !== undefined &&
            (otherProperties[i] == "implementation-dependent" || typeof gl[i] == otherProperties[i])) {
            // OK; known property of known type
        } else if (typeof gl[i] != "function") {
            if (!extended) {
                extended = true;
                testFailed("Also found the following extra properties:");
            }
            testFailed(i);
        }
    }

    if (!extended) {
        testPassed("No extra properties found on WebGL context.");
    }

    debug("");
    var successfullyParsed = true;;


    /******************* END TEST CASE *******************/



    if (ENVIRONMENT.postHook) {
        ENVIRONMENT.postHook();
    }
};
module.exports = context_constants_and_properties